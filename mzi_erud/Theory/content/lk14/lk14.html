<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top; /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%; /* Ширина первой колонки */
    }

    #col2 {
        width: 80%; /* Ширина второй колонки */
    }

    #col3 {
        width: 10%; /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>ЛЕКЦИЯ 14</strong>
            </h3>
            <p align="center">
                <strong style="font-size: 18px">ТЕМА 10 - Безопасность в открытых сетях</strong>
            </p>
            <p>
                <strong style="font-size: 17px">10.1. Алгоритмы обмена ключей и протоколы аутентификации.
                    Алгоритмы распределения ключей с использованием третьей доверенной
                    стороны</strong>
            </p>
            <p>
                <strong>Понятие мастер-ключа</strong>
            </p>
            <p>
                При симметричном шифровании два участника, которые хотят обмениваться
                конфиденциальной информацией, должны иметь один и тот же ключ. Частота
                изменения ключа должна быть достаточно большой, чтобы у противника не
                хватило времени для полного перебора ключа. Следовательно, сила любой
                криптосистемы во многом зависит от технологии распределения ключа. Этот
                термин означает передачу ключа двум участникам, которые хотят обмениваться
                данными, таким способом, чтобы никто другой не мог ни подсмотреть, ни
                изменить этот ключ. Для двух участников <em>А</em> и <em>B</em>
                распределение ключа может быть выполнено одним из следующих способов.
            </p>
            <ol>
                <li>
                    Ключ может быть создан <em>А</em> и физически передан <em>B</em>.
                </li>
                <li>
                    <em>Третья сторона</em> может создать ключ и физически передать его <em>А</em> и <em>B</em>.
                </li>
                <li>
                    <em>А</em> и <em>В</em> имеют предварительно созданный и недолго
                    используемый ключ, один участник может передать новый ключ другому,
                    применив для шифрования старый ключ.
                </li>
                <li>
                    Если А и В каждый имеют безопасное соединение с третьим участником<em>C</em>, <em>C</em> может
                    передать ключ по этому безопасному каналу <em>А</em> и <em>B</em>.
                </li>
            </ol>

            <p>
                Количество требуемых ключей зависит от числа участников, которые должны
                взаимодействовать. Если выполняется шифрование на сетевом или IP-уровне, то
                ключ необходим для каждой пары хостов в сети. Таким образом, если есть N
                хостов, то необходимое число ключей [N (N - 1)]/2. Если шифрование
                выполняется на прикладном уровне, то ключ нужен для каждой пары прикладных
                процессов, которых гораздо больше, чем хостов.
            </p>
            <p>
                Третий способ распределения ключей может применяться на любом уровне стека
                протоколов, но если атакующий получает возможность доступа к одному ключу,
                то вся последовательность ключей будет раскрыта. Более того, все равно
                должно быть проведено первоначальное распространение большого количества
                ключей.
            </p>
            <p>
                Поэтому в больших автоматизированных системах широко применяются различные
                варианты четвертого способа. В этой схеме предполагается существование так
                называемого центра распределения ключей (Key Destribution Centre - <em>KDC</em>), который отвечает за
                распределение ключей для хостов,
                процессов и приложений. Каждый участник должен разделять уникальный ключ с <em>KDC</em>.
            </p>
            <p>
                Использование центра распределения ключей основано на использовании
                иерархии ключей. Как минимум используется два типа ключей: <em>мастер-ключи</em> и <em>ключи сессии</em>.
            </p>
            <br/>
            <p>
                <strong style="font-size: 17px">10.2. Взаимная аутентификация</strong>
            </p>
            <p>
                Данные протоколы применяются для взаимной <em>аутентификации</em>
                участников и для обмена <em>ключом сессии</em>.
            </p>
            <p>
                Основной задачей таких протоколов является обеспечение конфиденциального
                распределения <em>ключа сессии</em> и гарантирование его своевременности,
                то есть протокол не должен допускать повторного использования старого<em>ключа сессии</em>. Для
                обеспечения конфиденциальности <em>ключи сессии</em> должны передаваться в зашифрованном виде. Вторая
                задача, обеспечение своевременности, важна, потому что существует угроза
                перехвата передаваемого сообщения и повторной его пересылки. Такие
                повторения в худшем случае могут позволять взломщику использовать
                скомпрометированный <em>ключ сессии</em>, при этом успешно подделываясь под
                другого участника. Успешное повторение может, как минимум, разорвать
                операцию <em>аутентификации</em> участников.
            </p>
            <p>
                Такие повторы называются <em>replay-атаками</em>. Рассмотрим возможные
                примеры подобных <em>replay-атак</em>:
            </p>
            <ol>
                <li>
                    Простое повторение: противник просто копирует сообщение и повторяет его
                    позднее.
                </li>
                <li>
                    Повторение, которое не может быть определено: противник уничтожает
                    исходное сообщение и посылает скопированное ранее сообщение.
                </li>
            </ol>

            <p>
                Один из возможных подходов для предотвращения <em>replay-атак</em> мог бы
                состоять в присоединении последовательного номера (sequence number) к
                каждому сообщению, используемому в <em>аутентификационном</em> обмене.
                Новое сообщение принимается только тогда, когда его последовательный номер
                правильный. Трудность данного подхода состоит в том, что каждому участнику
                требуется поддерживать значения sequence number для каждого участника, с
                которым он взаимодействует в данный момент. Поэтому обычно sequence number
                не используются для <em>аутентификации</em> и обмена ключами. Вместо этого
                применяется один из следующих способов:
            </p>
            <ol>
                <li>
                    <em>Отметки времени</em>: участник А принимает сообщение как не
                    устаревшее только в том случае, если оно содержит <em>отметку времени</em>,
                    которая, по мнению А, соответствует текущему времени. Этот подход требует,
                    чтобы часы всех участников были синхронизированы.
                </li>
                <li>
                    Запрос/ответ: участник А посылает в запросе к В случайное число ( <strong><em>nonce</em></strong> -
                    number only once) и проверяет, чтобы
                    ответ от В содержал корректное значение этого <em>nonce</em>.
                </li>
            </ol>

            <p>
                Считается, что подход с <em>отметкой времени</em> не следует использовать в
                приложениях, ориентированных на соединение, потому что это технически
                трудно, так как таким протоколам, кроме поддержки соединения, необходимо
                будет поддерживать синхронизацию часов различных процессоров. При этом
                возможный способ осуществления успешной атаки может возникнуть, если
                временно будет отсутствовать синхронизация часов одного из участников. В
                результате различной и непредсказуемой природы сетевых задержек
                распределенные часы не могут поддерживать точную синхронизацию.
                Следовательно, процедуры, основанные на любых <em>отметках времени</em>,
                должны допускать окно времени, достаточно большое для приспособления к
                сетевым задержкам, и достаточно маленькое для минимизации возможности атак.
            </p>
            <p>
                С другой стороны, подход запрос/ответ не годится для приложений, не
                устанавливающих соединения, так как он требует предварительного рукопожатия
                перед началом передач, тем самым отвергая основное свойство транзакции без
                установления соединения. Для таких приложений доверие к некоторому
                безопасному серверу часов и постоянные попытки каждой из частей
                синхронизировать свои часы с этим сервером может быть оптимальным подходом.
            </p>
            <br/>
            <p>
                <strong style="font-size: 17px">10.3. Использование симметричного шифрования
                </strong>
            </p>
            <p>
                Для обеспечения <em>аутентификации</em> и распределения <em>ключа сессии</em> часто используется
                двухуровневая иерархия ключей
                симметричного шифрования. В общих чертах эта стратегия включает
                использование доверенного центра распределения ключей (<em>KDC</em>).
                Каждый участник разделяет секретный ключ, называемый также <em>мастер-ключом</em>, с <em>KDC</em>. <em>KDC</em>
                отвечает за создание
                ключей, называемых <em>ключами сессии</em>, и за распределение этих ключей
                с использованием <em>мастер-ключей</em>. <em>Ключи сессии</em> применяются
                в течение короткого времени для шифрования только данной сессии между двумя
                участниками.
            </p>
            <p>
                Большинство алгоритмов распределения секретного ключа с использованием <em>KDC</em>, включает также
                возможность <em>аутентификации</em>
                участников.
            </p>
            <ol>
                <li>
                    <p>
                        <em>Протокол Нидхэма и Шредера</em>
                    </p>
                    <p>
                        Предполагается, что секретные <em>мастер-ключи</em> K<sub>A</sub> и K <sub>B</sub> разделяют
                        соответственно А и <em>KDC</em> и В и <em>KDC</em>.
                        Целью протокола является безопасное распределение <em>ключа сессии</em> KS
                        между А и В. Протокол представляет собой следующую последовательность
                        шагов:
                    </p>
                    <ol>
                        <li>
                            A → KDC: ID<sub>A</sub> || ID<sub>B</sub> || N<sub>1</sub>
                        </li>
                        <li>
                            KDC → A: E<sub>Ka</sub> [K<sub>S</sub> || ID<sub>B</sub> || N <sub>1</sub> || E<sub>Kb</sub>
                            [K<sub>S</sub> || ID<sub>A</sub>] ]
                        </li>
                        <li>
                            A → B: E<sub>Kb</sub> [K<sub>S</sub> || ID<sub>A</sub>]
                        </li>
                        <li>
                            B → A: E<sub>KS</sub> [N<sub>2</sub>]
                        </li>
                        <li>
                            A → B: E<sub>KS</sub> [f (N<sub>2</sub>)]
                        </li>
                    </ol>

                    <p>
                        А запрашивает у <em>KDC</em> <em>ключ сессии</em> для установления
                        защищенного соединения с В. Сообщение включает идентификацию А и В и
                        уникальный идентификатор данной транзакции, который обозначен как N <sub>1</sub> и называется
                        <em>nonce</em>. <em>Nonce</em> может быть
                        временной меткой, счетчиком или случайным числом; минимальное требование
                        состоит в том, чтобы он отличался для каждого запроса. Кроме того, для
                        предотвращения подделки желательно, чтобы противнику было трудно
                        предугадать <em>nonce</em>. Таким образом, случайное число является лучшим
                        вариантом для <em>nonce</em>.
                    </p>
                    <ol>
                        <li>
                            <em>KDC</em> отвечает сообщением, зашифрованным ключом K<sub>А</sub>.
                            Таким образом, только А может расшифровать сообщение, и А уверен, что оно
                            получено от <em>KDC</em>, так как предполагается, что кроме А и <em>KDC</em> этот ключ не
                            знает никто.
                            Это сообщение включает следующие
                            элементы, предназначенные для А:

                            <ul>
                                <li>
                                    Одноразовый <em>ключ сессии</em>.
                                </li>
                                <li>
                                    Идентификатор В.
                                </li>
                                <li>
                                    <em>nonce</em>, который идентифицирует данную сессию .
                                </li>
                            </ul>
                            <br/>
                            А должен убедиться, что полученный <em>nonce</em> равен значению<em>nonce</em> из первого
                            запроса. Это
                            доказывает, что ответ от <em>KDC</em> не был модифицирован при пересылке и не является
                            повтором
                            некоторого предыдущего запроса. Кроме того, сообщение включает два
                            элемента, предназначенные для В:
                            <ul>
                                <li>
                                    Одноразовый <em>ключ сессии</em> K<sub>S</sub>.
                                </li>
                                <li>
                                    Идентификатор А ID<sub>A</sub>.
                                </li>
                            </ul>

                            <p>
                                Эти два последних элемента шифруются <em>мастер-ключом</em>, который <em>KDC</em>
                                разделяет с В. Они
                                посылаются В при установлении соединения и
                                доказывают идентификацию А.
                            </p>
                        </li>

                        <li>
                            А сохраняет у себя <em>ключ сессии</em> и передает В информацию от<em>KDC</em>,
                            предназначенную В:
                            Е<sub>Kb</sub> [K<sub>S</sub> || ID <sub>A</sub>]. Так как эта информация зашифрована K<sub>В</sub>,
                            она
                            защищена от просмотра. Теперь В знает <em>ключ сессии</em> (K<sub>S</sub>),
                            знает, что другим участником является А, (ID<sub>A</sub>) и что начальная
                            информация передана от <em>KDC</em>, т.к. она зашифрована с использованием
                            K<sub>B</sub>.

                            <p>
                                В этой точке <em>ключ сессии</em> безопасно передан от А к В, и они могут
                                начать безопасный обмен. Тем не менее, существует еще два дополнительных
                                шага:
                            </p>
                        </li>

                        <li>
                            Используя созданный <em>ключ сессии</em>, В пересылает A <em>nonce</em>
                            N<sub>2</sub>.
                        </li>
                        <li>
                            Также используя K<sub>S</sub>, А отвечает f (N<sub>2</sub>), где f -
                            функция, выполняющая некоторую модификацию N<sub>2</sub>.
                        </li>
                    </ol>

                    <p>
                        Эти шаги гарантируют B, что сообщение, которое он получил, не изменено и не
                        является повтором предыдущего сообщения.
                    </p>
                    <p>
                        Заметим, что реальное распределение ключа включает только шаги 1 - 3, а
                        шаги 4 и 5, как и 3, выполняют функцию <em>аутентификации</em>.
                    </p>
                    <p>
                        А безопасно получает <em>ключ сессии</em> на шаге 2. Сообщение на шаге 3
                        может быть дешифровано только B. Шаг 4 отражает знание В ключа K <sub>S</sub>, и шаг 5
                        гарантирует В
                        знание участником А ключа K<sub>S</sub>
                        и подтверждает, что это не устаревшее сообщение, так как используется<em>nonce</em>
                        N<sub>2</sub>. Шаги
                        4 и 5 призваны предотвратить общий тип <em>replay-атак</em>. В частности, если противник имеет
                        возможность
                        захватить сообщение на шаге 3 и повторить его, то это должно привести к
                        разрыву соединения.
                    </p>
                    <p>
                        Разрывая рукопожатие на шагах 4 и 5, протокол все еще уязвим для некоторых
                        форм атак повторения. Предположим, что противник Х имеет возможность
                        скомпрометировать старый <em>ключ сессии</em>. Маловероятно, чтобы
                        противник мог сделать больше, чем просто копировать сообщение шага 3.
                        Потенциальный риск состоит в том, что Х может заставить взаимодействовать А
                        и B, используя старый <em>ключ сессии</em>. Для этого Х просто повторяет
                        сообщение шага 3, которое было перехвачено ранее и содержит
                        скомпрометированный <em>ключ сессии</em>. Если В не запоминает
                        идентификацию всех предыдущих <em>ключей сессий</em> с А, он не сможет
                        определить, что это повтор. Далее Х должен перехватить сообщение
                        рукопожатия на шаге 4 и представиться А в ответе на шаге 5.
                    </p>
                </li>

                <li>
                    <p>
                        <em>Протокол Деннинга</em>
                    </p>
                    <p>
                        Деннинг предложил преодолеть эту слабость модификацией протокола Нидхэма и
                        Шредера, которая включает дополнительную <em>отметку времени</em> на шагах
                        2 и 3:
                    </p>
                    <ol>
                        <li>
                            A → KDC: ID<sub>A</sub> || ID<sub>B</sub>
                        </li>
                        <li>
                            KDC → A: E<sub>Ka</sub> [K<sub>S</sub> || ID<sub>B</sub> || T || E <sub>Kb</sub>
                            [K<sub>S</sub> || ID<sub>A</sub>
                            || T] ]
                        </li>
                        <li>
                            A → B: E<sub>Kb</sub> [K<sub>S</sub> || ID<sub>A</sub> || T]
                        </li>
                        <li>
                            B → A: E<sub>KS</sub> [N<sub>1</sub>]
                        </li>
                        <li>
                            A → B: E<sub>KS</sub> [f (N<sub>1</sub>)]
                        </li>
                    </ol>

                    <p>
                        <em>Т</em>
                        – это <em>отметка времени</em>, которая гарантирует А и B, что <em>ключ сессии</em> является
                        только что
                        созданным. Таким образом, и А, и В
                        знают, что распределенный ключ не является старым. А и В могут
                        верифицировать <em>временную отметку</em> проверкой, что |Clock - T| &lt;
                        Δt<sub>1</sub> + Δt<sub>2</sub>
                    </p>
                    <p>
                        где Δ t<sub>1</sub> - оцениваемое нормальное расхождение между часами <em>KDC</em> и локальными
                        часами
                        (у А или B) и t<sub>2</sub> - ожидаемая
                        сетевая задержка времени. Каждый участник может установить свои часы,
                        ориентируясь на определенный доверенный источник. Поскольку<em>временная отметка</em> Т
                        шифруется с
                        использованием секретных <em>мастер-ключей</em>, взломщик, даже зная старый <em>ключ сессии</em>,
                        не
                        сможет достигнуть цели повторением шага 3 так, чтобы В не заметил искажения
                        времени.
                    </p>
                    <p>
                        Шаги 4 и 5 не были включены в первоначальное представление, но были
                        добавлены позднее. Эти шаги подтверждают А, что В получил <em>ключ сессии</em>.
                    </p>
                    <p>
                        Протокол Деннинга обеспечивает большую степень безопасности по сравнению с
                        протоколом Нидхэма и Шредера. Однако данная схема требует доверия к часам,
                        которые должны быть синхронизированы в сети. В этом есть определенный риск,
                        который состоит в том, что распределенные часы могут рассинхронизироваться
                        в результате диверсии или повреждений. Проблема возникает, когда часы
                        отправителя спешат по отношению к часам получателя. В этом случае противник
                        может перехватить сообщение от отправителя и повторить его позднее, когда <em>отметка
                        времени</em> в
                        сообщении станет равной времени на узле
                        получателя. Это повторение может иметь непредсказуемые последствия.
                    </p>
                    <p>
                        Один способ вычисления атак повторения состоит в требовании, чтобы
                        участники регулярно сверяли свои часы с часами <em>KDC</em>. Другая
                        альтернатива, при которой нет необходимости всем синхронизировать часы,
                        состоит в доверии протоколам рукопожатия, использующим <em>nonce</em>.
                    </p>
                </li>
            </ol>

            <a href="../lk15/lk15.html">Следующая лекция - Безопасность в открытых сетях (продолжение)
            </a>
        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
