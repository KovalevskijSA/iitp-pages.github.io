<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top; /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%; /* Ширина первой колонки */
    }

    #col2 {
        width: 80%; /* Ширина второй колонки */
    }

    #col3 {
        width: 10%; /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>ЛЕКЦИЯ 12</strong>
            </h3>
            <p>
                <strong style="font-size: 17px">8.3. Стандарт цифровой подписи DSS</strong>
            </p>

            <p>
                Для создания <em>цифровой подписи</em> используется алгоритм <em>DSA</em>
                (Digital Signature Algorithm). В качестве хэш-алгоритма стандарт
                предусматривает использование алгоритма SHA-1 (Secure Hash Algorithm).
            </p>
            <p>
                <em>DSS</em>
                использует алгоритм, который разрабатывался для использования только в
                качестве <em>цифровой подписи</em>.
            </p>
            <p>
                <em>DSS</em>
                основан на трудности вычисления дискретных логарифмов и базируется на
                схеме, первоначально представленной ElGamal и Schnorr.
            </p>
            <p>
                Существует три параметра, которые являются открытыми и могут быть общими
                для большой группы пользователей.
            </p>
            <p>
                160-битное простое число q, т.е. 2<sup>159</sup> &lt; q &lt; 2 <sup>160</sup>.
            </p>
            <p>
                Простое число р длиной между 512 и 1024 битами должно быть таким, чтобы q
                было делителем (р - 1), т.е. 2<sup>L-1</sup> &lt; p &lt; 2<sup>L</sup>, где
                512 &lt; L &lt; 1024 и (p-1)/q является целым.
            </p>
            <p>
                g = h<sup>(p-1)/q</sup> mod p, где h является целым между 1 и (р-1) и g
                должно быть больше, чем 1,10.
            </p>
            <p>
                Зная эти числа, каждый пользователь выбирает закрытый ключ и создает
                открытый ключ.
            </p>
            <ol>
                <li>
                    Закрытый ключ отправителя

                    <p>
                        Закрытый ключ х должен быть числом между 1 и (q-1) и должен быть выбран
                        случайно или псевдослучайно.
                    </p>
                    <p>
                        x - случайное или псевдослучайное целое, 0 &lt; x &lt; q.
                    </p>
                    <p>
                </li>
                <li>
                    Открытый ключ отправителя

                    <p>
                        Открытый ключ вычисляется из закрытого ключа как у = g<sup>x</sup> mod p.
                        Вычислить у по известному х довольно просто. Однако, имея открытый ключ у,
                        вычислительно невозможно определить х, который является дискретным
                        логарифмом у по основанию g.
                    </p>
                    <p>
                        y = g<sup>x</sup> mod p
                    </p>
                </li>

                <li>
                    Случайное число, уникальное для каждой подписи.

                    <p>
                        <em>k</em>
                        - случайное или псевдослучайное целое, 0 &lt; k &lt; q, уникальное для
                        каждого подписывания.
                    </p>
                </li>

                <li>
                    Подписывание

                    <p>
                        Для создания подписи отправитель вычисляет две величины, r и s, которые
                        являются функцией от компонент открытого ключа (p, q, g), закрытого ключа
                        пользователя (х), хэш-кода сообщения Н (М) и целого k, которое должно быть
                        создано случайно или псевдослучайно и должно быть уникальным при каждом
                        подписывании.
                    </p>
                    <ul>
                        <li>
                            r = (g<sup>k</sup> mod p) mod q
                        </li>
                        <li>
                            s = [ k<sup>-1</sup> (H (M) + xr) ] mod q
                        </li>
                    </ul>

                    <p>
                        Подпись = (r, s)
                    </p>
                    <p>
                </li>

                <li>
                    Проверка подписи

                    <p>
                        Получатель выполняет проверку подписи с использованием следующих формул. Он
                        создает величину v, которая является функцией от компонент общего открытого
                        ключа, открытого ключа отправителя и хэш-кода полученного сообщения. Если
                        эта величина равна компоненте r в подписи, то подпись считается
                        действительной.
                    </p>
                    <ol>
                        <li>
                            w = s<sup>-1</sup> mod q
                        </li>
                        <li>
                            u<sub>1</sub> = [ H (M) w ] mod q
                        </li>
                        <li>
                            u<sub>2</sub> = r w mod q
                        </li>
                        <li>
                            v = [ (g<sup>u1</sup> y<sup>u2</sup>) mod p ] mod q
                        </li>
                        <li>
                            подпись корректна, если v = r.
                        </li>
                    </ol>
                </li>

            </ol>


            <br/>
            <p>
                <strong style="font-size: 17px">8.4. Отечественный стандарт цифровой подписи ГОСТ 3410</strong>
            </p>
            <p>
                В стандарте <em>ГОСТ 3410</em> используется хэш-функция ГОСТ 3411, которая
                создает хэш-код длиной 256 бит. Это во многом обуславливает требования к
                выбираемым простым числам p и q:
            </p>
            <ul>
                <li>
                    р должно быть простым числом в диапазоне 2<sup>509</sup> &lt; p &lt; 2<sup>512 </sup>либо 2<sup>1020</sup> &lt; p
                    &lt; 2<sup>1024</sup>
                </li>
                <li>
                    q должно быть простым числом в диапазоне 2<sup>254</sup> &lt; q &lt; 2<sup>256</sup>, q также должно быть делителем (р-1).
                </li>
            </ul>

            <p>
                Аналогично выбирается и параметр g. При этом требуется, чтобы g<sup>q</sup>
                (mod p) = 1.
            </p>
            <p>
                В соответствии с теоремой Ферма это эквивалентно условию в <em>DSS</em>,
                что g = h<sup>(p-1)/q</sup> mod p.
            </p>
            <p>
                Закрытым ключом является произвольное число х: 0 &lt; x &lt; q
            </p>
            <p>
                Открытым ключом является число y: y = g<sup>x</sup> mod p
            </p>
            <p>
                Для создания подписи выбирается случайное число k: 0 &lt; k &lt; q
            </p>
            <p>
                Подпись состоит из двух чисел (r, s), вычисляемых по следующим формулам:
            </p>
            <ul>
                <li>
                    r = (g<sup>k</sup> mod p) mod q
                </li>
                <li>
                    s = (k H(M) + xr) mod q
                </li>
            </ul>

            <p>
                Обратим внимание на отличия <em>DSS</em> и <em>ГОСТ 3410</em>.
            </p>
            <ol>
                <li>
                    Используются разные хэш-функции: в <em>ГОСТ 3410</em> применяется
                    отечественный стандарт на хэш-функции ГОСТ 3411, в <em>DSS</em>
                    используется SHA-1, которые имеют разную длину хэш-кода. Отсюда и разные
                    требования на длину простого числа q: в <em>ГОСТ 3410</em> длина q должна
                    быть от 254 бит до 256 бит, а в <em>DSS</em> длина q должна быть от 159 бит
                    до 160 бит.
                </li>
                <li>
                    По-разному вычисляется компонента s подписи.
                </li>
            </ol>

            <p>
                В <em>ГОСТ 3410</em> компонента s вычисляется по формуле: s = (k H(M) + xr)
                mod q
            </p>
            <p>
                В <em>DSS</em> компонента s вычисляется по формуле: s = [k<sup>-1</sup>
                (H(M) + xr)] mod q
            </p>
            <p>
                Последнее отличие приводит к соответствующим отличиям в формулах для
                проверки подписи.
            </p>
            <p>
                Получатель вычисляет
            </p>
            <ol>
                <li>
                    w = H(M)<sup>-1</sup> mod q
                </li>
                <li>
                    u<sub>1</sub> = w s mod q
                </li>
                <li>
                    u<sub>2</sub> = (q-r) w mod q
                </li>
                <li>
                    v = [(g<sup>u1</sup> y<sup>u2</sup>) mod p] mod q
                </li>
                <li>
                    Подпись корректна, если v = r.
                </li>
            </ol>

            <p>
                Структура обоих алгоритмов довольно интересна. Заметим, что значение r
                совсем не зависит от сообщения. Вместо этого r есть функция от k и трех
                общих компонент открытого ключа. Мультипликативная инверсия k (mod p) (в
                случае <em>DSS</em>) или само значение k (в случае ГОСТ 3410) подается в
                функцию, которая, кроме того, в качестве входа имеет хэш-код сообщения и
                закрытый ключ пользователя. Эта функция такова, что получатель может
                вычислить r, используя входное сообщение, подпись, открытый ключ
                пользователя и общий открытый ключ.
            </p>
            <p>
                В силу сложности вычисления дискретных логарифмов нарушитель не может
                восстановить k из r или х из s.
            </p>
            <p>
                Другое важное замечание заключается в том, что экспоненциальные вычисления
                при создании подписи необходимы только для g<sup>k</sup> mod p. Так как это
                значение от подписываемого сообщения не зависит, оно может быть вычислено
                заранее. Пользователь может заранее просчитать некоторое количество
                значений r и использовать их по мере необходимости для подписи документов.
                Еще одна задача состоит в определении мультипликативной инверсии k <sup>-1</sup> (в случае <em>DSS</em>).
                Эти значения также могут быть
                вычислены заранее. <em></em>
            </p>
            <a href="../lk13/lk13.html">Следующая лекция - Криптография с использованием эллиптических кривых
            </a>
        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
