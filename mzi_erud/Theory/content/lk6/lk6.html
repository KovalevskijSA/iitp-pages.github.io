<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top; /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%; /* Ширина первой колонки */
    }

    #col2 {
        width: 80%; /* Ширина второй колонки */
    }

    #col3 {
        width: 10%; /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>ЛЕКЦИЯ 6</strong>
            </h3>
            <p>
                <strong style="font-size: 17px"> 4.3. Алгоритм АЕS</strong>
            </p>

            <p>
                Инициатива в разработке <em>AES</em> принадлежит NIST. В августе 1999 года
                были представлены пять финалистов. Ими стали <em>MARS</em>, <em>RC6™</em>, <em>Rijndael</em>, <em>Serpent</em>
                и <em>Twofish</em>. В итоге в качестве
                нового стандарта был принят <em>Rijndael.</em>
            </p>
            <p>
                Практически все операции Rijndael определяются на уровне байта. Байты можно
                рассматривать как элементы конечного поля GF (2<sup>8</sup>). Некоторые
                операции определены в терминах четырехбайтных слов.
            </p>
            <p>
                <strong>Поле GF(2<sup>8</sup>)</strong>
            </p>
            <p>
                Элементы конечного поля могут быть представлены несколькими различными
                способами. Для любой степени простого числа существует единственное
                конечное поле, поэтому все представления GF (2<sup>8</sup>) являются
                изоморфными. Несмотря на подобную эквивалентность, представление влияет на
                сложность реализации. Выберем классическое полиномиальное представление.
            </p>
            <p>
                Байт b, состоящий из битов b<sub>7</sub>, b<sub>6</sub>, b<sub>5</sub>, b <sub>4</sub>, b<sub>3</sub>, b<sub>2</sub>,
                b<sub>1</sub>, b<sub>0</sub>,
                представляется в виде полинома с коэффициентами из {0, 1}:
            </p>
            <p>
                b<sub>7</sub>х<sup>7</sup> + b<sub>6</sub>х<sup>6</sup> + b<sub>5</sub>х<sup>5</sup> +
                b<sub>4</sub>х<sup>4</sup> + b<sub>3</sub>х<sup>3</sup> + b <sub>2</sub>х<sup>2</sup> +
                b<sub>1</sub>х<sup>1</sup> + b<sub>0</sub>
            </p>
            <p>
                В полиномиальном представлении сумма двух элементов является полиномом с
                коэффициентами, которые равны сумме по модулю 2 коэффициентов слагаемых.
            </p>
            <p>
                В полиномиальном представлении умножение в GF (2<sup>8</sup>) соответствует
                умножению полиномов по модулю неприводимого двоичного полинома степени 8.
                Полином является неприводимым, если он не имеет делителей, кроме 1 и самого
                себя. Для Rijndael такой полином называется m(x) и определяется следующим
                образом:
            </p>
            <p>
                m(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup> + x + 1
            </p>
            <p>
                Умножение, определенное выше, является ассоциативным, и существует
                единичный элемент ('01'). Для любого двоичного полинома b(x) не выше 8-й
                степени можно использовать расширенный алгоритм Евклида для вычисления
                полиномов a(x) и c(x) таких, что b(x) a(x) + m(x) c(x) = 1
            </p>
            <p>
                Следовательно, <em>a(x) • b(x) mod m(x) = 1</em> или <em>b<sup>-1</sup>(x) = a(x) mod m(x)</em>
            </p>
            <p>
                Более того, можно показать, что <em>a(x) • (b(x) + c(x)) = a(x) • b(x) + a(x) • c(x)</em>
            </p>
            <p>
                Из всего этого следует, что множество из 256 возможных значений байта
                образует конечное поле GF (2<sup>8</sup>) c XOR в качестве сложения и
                умножением, определенным выше.
            </p>
            <p>
                Если умножить b(x) на полином х, мы будем иметь:
            </p>
            <p>
                b<sub>7</sub>x<sup>8</sup> + b<sub>6</sub>x<sup>7</sup> + b<sub>5</sub>x<sup>6</sup> +
                b<sub>4</sub>x<sup>5</sup> + b<sub>3</sub>x<sup>4</sup> + b <sub>2</sub>x<sup>3</sup> +
                b<sub>1</sub>x<sup>2</sup> + b<sub>0</sub>x
            </p>
            <p>
                x • b(x) получается понижением предыдущего результата по модулю m(x). Если
                b<sub>7</sub> = 0, то данное понижение является тождественной операцией.
                Если b<sub>7</sub> = 1, m(x) следует вычесть (т.е. XORed). Из этого
                следует, что умножение на х может быть реализовано на уровне байта как
                левый сдвиг и последующий побитовый XOR c '1B'. Данная операция
                обозначается как b = xtime (a).
            </p>
            <p>
                Полиномы могут быть определены с коэффициентами из GF(2<sup>8</sup>). В
                этом случае четырехбайтный вектор соответствует полиному степени 4.
            </p>
            <p>
                Полиномы могут быть сложены простым сложением соответствующих
                коэффициентов. Как сложение в GF(2<sup>8</sup>) является побитовым XOR, так
                и сложение двух векторов является простым побитовым XOR.
            </p>
            <p>
                <strong>Умножение на х</strong>
            </p>
            <p>
                При умножении b(x) на полином х будем иметь: b<sub>3</sub>x<sup>4</sup> + b<sub>2</sub>x<sup>3</sup> + b<sub>1</sub>x <sup>2</sup> + b<sub>0</sub>x
            </p>
            <p>
                x ⊕ b(x) получается понижением предыдущего результата по модулю 1 + х <sup>4</sup>.
            </p>
            <p>
                Это дает
                b<sub>2</sub>x<sup>3</sup> + b<sub>1</sub>x<sup>2</sup> + b<sub>0</sub>x +
                b<sub>3</sub>
            </p>
            <p>
                Умножение на х эквивалентно умножению на матрицу, как описано выше со всеми
                a<sub>i</sub> = '00' за исключением а<sub>1</sub> = '01'. Имеем:
            </p>
            <p align="center">
                <img
                        src="../../images/lk6/1.png"
                        alt="matr2"
                />
            </p>
            <p>
                Следовательно, умножение на х соответствует циклическому сдвигу байтов
                внутри вектора.
            </p>
            <p>
                В большинстве алгоритмов шифрования преобразование каждого раунда имеет
                структуру сети Фейштеля . В этом случае обычно часть битов в каждом
                промежуточном состоянии просто перемещается без изменения в другую
                половину. Преобразование раунда алгоритма Rijndael не имеет структуру сети
                Фейштеля. Вместо этого преобразование каждого раунда состоит из четырех
                различных преобразований, называемых слоями.
            </p>
            <p>
                Каждый слой разрабатывался с учетом противодействия линейному и
                дифференциальному криптоанализу. В основу каждого слоя положена своя
                собственная функция:
            </p>
            <ol>
            <li>
                Нелинейный слой состоит из параллельного применения S-boxes для
                оптимизации нелинейных свойств в наихудшем случае.
            </li>
            <li>
                Слой линейного перемешивания строк гарантирует высокую степень диффузии
                для нескольких раундов.
            </li>
            <li>
                Слой линейного перемешивания столбцов также гарантирует высокую степень
                диффузии для нескольких раундов.
            </li>
            <li>
                Дополнительный слой ключа состоит из простого XOR промежуточного
                состояния с ключом раунда.
            </li>
            </ol>
            <p>
                Перед первым раундом применяется дополнительное забеливание с
                использованием ключа. Причина этого состоит в следующем. Любой слой после
                последнего или до первого добавления ключа может быть просто снят без
                знания ключа и тем самым не добавляет безопасности в алгоритм (например,
                начальная и конечная перестановки в DES). Начальное или конечное добавление
                ключа применяется также в некоторых других алгоритмах, например IDEA, SAFER
                и Blowfish.
            </p>
            <p>
                <strong>Спецификация алгоритма</strong>
            </p>
            <p>
                Rijndael является блочным алгоритмом шифрования с переменной длиной блока и
                переменной длиной ключа. Длина блока и длина ключа могут быть независимо
                установлены в 128, 192 или 256 бит.
            </p>
            <p>
                <strong>Состояние, ключ шифрования и число раундов</strong>
            </p>
            <p>
                Различные преобразования выполняются над промежуточным результатом,
                называемым состоянием.
            </p>
            <p>
                Состояние можно рассматривать как двумерный массив байтов. Этот массив
                имеет четыре строки и различное число столбцов, обозначаемое как Nb, равное
                длине блока, деленной на 32. Ключ также можно рассматривать как двумерный
                массив с четырьмя строками. Число столбцов ключа шифрования, обозначаемое
                как Nk, равно длине ключа, деленной на 32.
            </p>
            <p>
                В некоторых случаях эти блоки также рассматриваются как одномерные массивы
                четырехбайтных векторов, где каждый вектор состоит из соответствующего
                столбца. Такие массивы имеют длину 4, 6 или 8 соответственно, и индексы в
                диапазонах 0 … 3, 0 … 5 или 0 … 7. Четырехбайтные вектора иногда мы будем
                называть словами.
            </p>
            <p>
                Если необходимо указать четыре отдельных байта в четырехбайтном векторе,
                будет использоваться нотация (a, b, c, d), где a, b, c и d являются байтами
                в позициях 0, 1, 2 и 3, соответственно, в рассматриваемом столбце, векторе
                или слове.
            </p>
            <p align="center">
                <a name="image.6.1"></a>
                <img
                        src="../../images/lk6/2.png"
                        alt="Пример состояния (с Nb = 6) и ключа шифрования (с Nk = 4)"
                />
            </p>
            <p align="center">
                Рисунок 4.3 – Пример состояния (с Nb = 6) и ключа шифрования (с Nk = 4)
            </p>
            <p>
                Входы и выходы Rijndael считаются одномерными массивами из 8 байтов,
                пронумерованными от 0 до 4* Nb - 1. Следовательно, эти блоки имеют длину
                16, 24 или 32 байта, и массив индексируется в диапазонах 0 … 15, 0 … 23 или
                0 … 31. Ключ считается одномерным массивом 8-битных байтов, пронумерованных
                от 0 до 4* Nk - 1. Следовательно, эти блоки имеют длину 16, 24 или 32
                байта, и массив индексируется в диапазонах 0 … 15, 0 … 23 или 0 … 31.
            </p>
            <p>
                Входные байты алгоритма отображаются в байты состояния в следующем порядке:
                А<sub>0,0</sub>, А<sub>1,0</sub>, А<sub>2,0</sub>, А<sub>3,0</sub>, А <sub>0,1</sub>, А<sub>1,1</sub>, А<sub>2,1</sub>,
                А<sub>3,1</sub>, … Байты
                ключа шифрования отображаются в массив в следующем порядке: K<sub>0,0</sub>
                , K<sub>1,0</sub>, K<sub>2,0</sub>, K<sub>3,0</sub>, K<sub>0,1</sub>, K <sub>1,1</sub>, K<sub>2,1</sub>,
                K<sub>3,1</sub>, … После выполнения
                операции шифрования выход алгоритма получается из байтов состояния
                аналогичным образом.
            </p>
            <p>
                Следовательно, если одноразмерный индекс байта в блоке есть n, и двухмерный
                индекс есть (i,j), то мы имеем:
            </p>
            <p>
                I = n mod 4
            </p>
            <p>
                J = n / 4
            </p>
            <p>
                N = i + 4*j
            </p>
            <p>
                Более того, индекс i является также номером байта в четырехбайтном векторе
                или слове, j является индексом вектора или слова во вложенном блоке.
            </p>
            <p>
                Число раундов обозначается Nr и зависит от значений Nb и Nk, что показано в
                следующей таблице.
            </p>


            <table border="1" cellspacing="1" cellpadding="0" align="center">
                <thead>
                <tr>
                    <td width="147">
                        <p>
                            <strong>Nr</strong>
                        </p>
                    </td>
                    <td width="141">
                        <p>
                            <strong>Nb = 4 </strong>
                        </p>
                    </td>
                    <td width="137">
                        <p>
                            <strong>Nb = 6 </strong>
                        </p>
                    </td>
                    <td width="141">
                        <p>
                            <strong>Nb = 8</strong>
                        </p>
                    </td>
                </tr>

                </thead>
                <tbody>

                <tr>
                    <td width="147">
                        <p>
                            <strong>Nk = 4 </strong>
                        </p>
                    </td>
                    <td width="141" valign="top">
                        <p>
                            10
                        </p>
                    </td>
                    <td width="137" valign="top">
                        <p>
                            12
                        </p>
                    </td>
                    <td width="141" valign="top">
                        <p>
                            14
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="147">
                        <p>
                            <strong>Nk = 6 </strong>
                        </p>
                    </td>
                    <td width="141" valign="top">
                        <p>
                            12
                        </p>
                    </td>
                    <td width="137" valign="top">
                        <p>
                            12
                        </p>
                    </td>
                    <td width="141" valign="top">
                        <p>
                            14
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="147">
                        <p>
                            <strong>Nk = 8 </strong>
                        </p>
                    </td>
                    <td width="141" valign="top">
                        <p>
                            14
                        </p>
                    </td>
                    <td width="137" valign="top">
                        <p>
                            14
                        </p>
                    </td>
                    <td width="141" valign="top">
                        <p>
                            14
                        </p>
                    </td>
                </tr>
                </tbody>
            </table>
            <p>
                <strong>Преобразование раунда</strong>
            </p>
            <p>
                Преобразование раунда состоит из четырех различных преобразований. В
                нотации на псевдо С это можно записать следующим образом:
            </p>
            <pre>
                <code>Round (State, RoundKey) {
                    ByteSub (State);
                    ShiftRow (State);
                    MixColumn (State);
                    AddRoundKey (State, RoundKey);
                }</code></pre>
            <p>
                Заключительный раунд алгоритма немного отличается и выглядит следующим
                образом:
            </p>
            <pre>
                <code>FinalRound (State, RoundKey) {
                   ByteSub (State);
                   ShiftRow (State);
                   AddRoundKey (State, RoundKey);
                }</code></pre>
            <p>
                Как мы видим, заключительный раунд эквивалентен остальным, за исключением
                того, что отсутствует слой MixColumn.
            </p>
            <p>
                <strong>Создание ключей раунда</strong>
            </p>
            <p>
                Ключи раунда получаются из ключа шифрования с помощью преобразования,
                состоящего из двух компонентов: расширение ключа и выбор ключа раунда.
                Основной принцип состоит в следующем:
            </p>
            <ol>
            <li>
                Общее число битов ключа раунда равно длине блока, умноженной на
                количество раундов плюс 1. Например, для длины блока 128 бит и 10 раундов
                необходимо 1408 битов ключа раунда.
            </li>
            <li>
                Ключ шифрования расширяется в ExpandedKey.
            </li>
            <li>
                Ключи раунда получаются из этого ExpandedKey следующим способом: первый
                ключ раунда состоит из первых Nb слов, второй состоит из следующих Nb слов
                и т.д.
            </li>
            </ol>
            <p>
                <strong>Расширение ключа</strong>
            </p>
            <p>
                Expanded Key является линейным массивом четырехбайтных слов и обозначается
                как W [Nb * (Nr + 1)]. Первые Nk слов состоят из ключа шифрования.
                Остальные слова определяются рекурсивно. Функция расширения ключа зависит
                от значения Nk: существует версия функции для Nk, равным или меньшим 6, и
                версия для Nk больше 6.
            </p>
            <p>
                Для Nk ≤ 6 мы имеем:
            </p>
            <pre>
                <code>KeyExpansion (byte Key [4*Nk]
                word W[Nb * (Nr + 1)]) {
                  for (i = 0; i < Nk; i++)
                    W[i] =(Key [4*i], Key [4*i+1],
                           Key [4*i+2], Key [4*i+3]);
                  for (i = Nk; i < Nb * (Nr + 1); i++) {
                    temp = W [i - 1];
                    if (i % Nk == 0)
                      temp = SubByte (RotByte (temp)) ^ Rcon [i / Nk];
                    W [i] = W [i- Nk] ^ temp;
                  }
                }</code></pre>
            <p>
                В данном случае SubByte (W) является функцией, которая возвращает
                четырехбайтное слово, в котором каждый байт является результатом применения
                S-box Rijndael к байту в соответствующей позиции во входном слове. Функция
                RotByte (W) возвращает слово, в котором байты циклически переставлены таким
                образом, что для входного слова (a, b, c, d) создается выходное слово (b,
                c, d, a).
            </p>
            <p>
                Можно заметить, что первые Nk слов заполняются ключом шифрования. Каждое
                следующее слово W[i] равно XOR предыдущего слова W[i-1] и позиций слова Nk
                до W[i - Nk]. Для слов в позициях, которые кратны Nk, сначала применяется
                преобразование XOR к W[i-1] и константой раунда. Данное преобразование
                состоит из циклического сдвига байтов в слове RotByte, за которым следут
                применение табличной подстановки для всех четырех байтов в слове (SubByte).
            </p>
            <p>
                Для Nk &gt; 6 мы имеем:
            </p>
            <pre>
                <code>KeyExpansion (byte Key [4*Nk]
                word W [Nb* (Nr+1)]) {
                  for (i=0; i < Nk; i++)
                    W[i]= (key [4*i], key [4*i+1],
                          key [4*i+2], key [4*i+3]);
                  for (i = Nk; i < Nb * (Nr + 1); i++) {
                    temp = W [i-1];
                    if (i % Nk == 0)
                      temp = SubByte (RotByte (temp)) ^
                             Rcon [i / Nk];
                    else if (i % Nk == 4)
                      temp = SubByte (temp);
                    W[i] = W[i - Nk] ^ temp;
                  }
                }</code></pre>
            <p>
                Отличие в схеме для Nk < 6 состоит в том, что для i-4 кратных Nk, SubByte применяется для W[i-1]
                перед XOR.
            </p>
            <p>
                Константы раунда не зависят от Nk и определяются следующим образом:
            </p>
            <pre>
                <code>Rcon [i] = (RC [i], '00', '00', '00')
                RC [i] являются элементами в GF (2<sup>8</sup>) со значением x <sup>(i-1)</sup> таким, что:
                RC [1] = 1 (т.е. '01')
                RC [i] = x (т.е. '02') • (RC [i-1]) = x(i-1)
                Ключ раунда i получается из слов буфера ключа раунда W [Nb * i] до W [Nb * (i+1)].</code></pre>
            <p>

            </p>
            <p>
                <strong>Алгоритм шифрования</strong>
            </p>
            <p>
                Алгоритм шифрования Rijndael состоит из
            </p>
            <ul>
            <li>
                начального сложения с ключом;
            </li>
            <li>
                Nr - 1 раундов;
            </li>
            <li>
                заключительного раунда.
            </li>
            </ul>
            <p>
                В С-подобном представлении это выглядит так:
            </p>
            <pre>
                <code>Rijndael (State, CipherKey) {
                   KeyExpansion (CipherKey, ExpandedKey);
                   AddRoundKey (State, ExpandedKey);
                   for (i=1; i < Nr; i++)
                      Round (State, ExpandedKey + Nb*i);
                   FinalRound (State, ExpandedKey + Nb*Nr)
                }</code></pre>
            <p>
                Расширение ключа может быть выполнено заранее, и Rijndael может быть
                специфицирован в терминах расширенного ключа.
            </p>
            <pre>
                <code>Rijndael (State, ExpandedKey) {
                       AddRoundKey (State, ExpandedKey);
                       for (i=1; i < Nr; i++)
                          Round (State, ExpandedKey + Nb*i);
                       FinalRound (State, ExpandedKey + Nb*Nr)
                   }</code>
            </pre>
            <p>
                Замечание: расширенный ключ всегда получается из ключа шифрования и никогда
                не специфицируется непосредственно. Тем не менее, на выбор самого ключа
                шифрования ограничений не существует.
            </p>

            <a href="../lk7/lk7.html">Следующая лекция - Криптография с открытым ключом
            </a>
        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
