<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top; /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%; /* Ширина первой колонки */
    }

    #col2 {
        width: 80%; /* Ширина второй колонки */
    }

    #col3 {
        width: 10%; /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>ЛЕКЦИЯ 10</strong>
            </h3>
            <p align="center">
                <strong style="font-size: 18px">ТЕМА 7 - Коды аутентификации сообщений - МАС</strong>
            </p>
            <p>
                <strong style="font-size: 17px">7.1. Требования к MAC</strong>
            </p>
            <p>
                Один из способов обеспечения целостности - это вычисление <em>МАС</em>
                (Message Authentication Code). Под <em>МАС</em> понимается некоторый
                аутентификатор, являющийся определенным способом вычисленным блоком данных,
                с помощью которого можно проверить целостность сообщения. В некоторой
                степени симметричное шифрование всего сообщения может выполнять функцию
                аутентификации этого сообщения. Но в таком случае сообщение должно
                содержать достаточную избыточность, которая позволяла бы проверить, что
                сообщение не было изменено. Избыточность может быть в виде определенным
                образом отформатированного сообщения, текста на конкретном языке и т.п.
                Если сообщение допускает произвольную последовательность битов (например,
                зашифрован ключ сессии), то симметричное шифрование всего сообщения не
                может обеспечивать его целостность, так как при дешифровании в любом случае
                получится последовательность битов, правильность которой проверить нельзя.
                Поэтому гораздо чаще используется критографически созданный небольшой блок
                данных фиксированного размера, так называемый аутентификатор или
                имитовставка, с помощью которого проверяется целостность сообщения. Этот
                блок данных может создаваться с помощью секретного ключа, который разделяют
                отправитель и получатель. <em>МАС</em> вычисляется в тот момент, когда
                известно, что сообщение корректно. После этого <em>МАС</em> присоединяется
                к сообщению и передается вместе с ним получателю. Получатель вычисляет <em>МАС</em>, используя тот же
                самый секретный ключ, и сравнивает
                вычисленное значение с полученным. Если эти значения совпадают, то с
                большой долей вероятности можно считать, что при пересылке изменения
                сообщения не произошло.
            </p>
            <p>
                MAC = CK (M)
            </p>
            <p>
                Предположим, что конфиденциальности сообщения нет, т.е. оппонент имеет
                доступ к открытому сообщению и соответствующему ему значению <em>МАС</em>.
                Определим усилия, необходимые оппоненту для нахождения ключа <em>МАС</em>.
                Предположим, что k &gt; n, т.е. длина ключа больше длины <em>МАС</em>.
                Тогда, зная М<sub>1</sub> и МАС<sub>1</sub> = С<sub>K</sub> (M<sub>1</sub>
                ), оппонент может вычислить МАС<sub>1</sub> = СK<sub>i</sub> (M<sub>1</sub>
                ) для всех возможных ключей K<sub>i</sub>. При этом, по крайней мере, для
                одного из ключей будет получено совпадение MAC<sub>i</sub> = MAC <sub>1</sub>. Оппонент вычислит
                2<sup>k</sup> значений <em>МАС</em>, тогда
                как при длине <em>МАС</em> n битов существует всего 2<sup>n</sup> значений<em>МАС</em>. Мы предположили,
                что k &gt; n, т.е. 2<sup>k</sup> &gt; 2 <sup>n</sup>. Таким образом, правильное значение <em>МАС</em>
                будет
                получено для нескольких значений ключей. В среднем совпадение будет иметь
                место для 2<sup>k</sup> / 2<sup>n</sup> = 2<sup>(k-n)</sup> ключей. Поэтому
                для вычисления единственного ключа оппоненту требуется знать несколько пар
                сообщение и соответствующий ему <em>МАС</em>.
            </p>
            <p>
                Таким образом, простой перебор всех ключей требует не меньше, а больше
                усилий, чем поиск ключа симметричного шифрования той же длины.
            </p>
            <p>
                Функция вычисления <em>МАС</em> должна обладать следующими свойствами:
            </p>
            <ol>
                <li>
                    Должно быть вычислительно трудно, зная М и С<sub>K</sub> (M), найти
                    сообщение М′, такое, что С<sub>K</sub>(M) = С<sub>K</sub>(M′).
                </li>
                <li>
                    Значения С<sub>K</sub>(M) должны быть равномерно распределенными в том
                    смысле, что для любых сообщений М и M′ вероятность того, что С<sub>K</sub>
                    (M) = С<sub>K</sub>(M′), должна быть равна 2<sup>-n</sup>, где n - длина
                    значения МАС.
                </li>
            </ol>

            <br/>
            <p>
                <strong style="font-size: 17px">7.2. МАС на основе алгоритма симметричного шифрования</strong>
            </p>
            <p>
                Для вычисления <em>МАС</em> может использоваться алгоритм симметричного
                шифрования (например, DES) в режиме СВС и нулевой инициализационный вектор.
                В этом случае сообщение представляется в виде последовательности блоков,
                длина которых равна длине блока алгоритма шифрования. При необходимости
                последний блок дополняется справа нулями, чтобы получился блок нужной
                длины. Вычисление <em>МАС</em> происходит по следующей схеме:
            </p>
            <p>
                МАС<sub>1</sub> = E<sub>K</sub> [P<sub>1</sub>]
            </p>
            <p>
                МАС<sub>2</sub> = E<sub>K</sub> [P<sub>2</sub> ⊕
                MAC<sub>1</sub>]
            </p>
            <p>
                . . .
            </p>
            <p>
                МАС<sub>N</sub> = E<sub>K</sub> [P<sub>N</sub> ⊕
                MAC<sub>N-1</sub>]
            </p>
            <p>
                MAC = МАС<sub>N</sub>
            </p>
            <br/>
            <p>
                <strong style="font-size: 17px">7.3. МАС на основе хэш-функции</strong>
            </p>
            <p>
                Другим способом обеспечения целостности является использование хэш-функции.
                Хэш-код присоединяется к сообщению в тот момент, когда известно, что
                сообщение корректно. Получатель проверяет целостность сообщения вычислением
                хэш-кода полученного сообщения и сравнением его с полученным хэш-кодом,
                который должен быть передан безопасным способом. Одним из таких безопасных
                способов может быть шифрование хэш-кода закрытым ключом отправителя, т.е.
                создание подписи. Возможно также шифрование полученного хэш-кода алгоритмом
                симметричного шифрования, если отправитель и получатель имеют общий ключ
                симметричного шифрования.
            </p>
            <p>
                Еще один вариант использования хэш-функции для получения <em>МАС</em>
                состоит в том, чтобы определенным образом добавить секретное значение к
                сообщению, которое подается на вход хэш-функции. Такой алгоритм носит
                название <em>НМАС</em>, и он описан в RFC 2104.
            </p>
            <p>
                При разработке алгоритма НМАС преследовались следующие цели:
            </p>
            <ul type="disc">
                <li>
                    возможность использовать без модификаций уже имеющиеся хэш-функции;
                </li>
                <li>
                    возможность легкой замены встроенных хэш-функций на более быстрые или
                    более стойкие;
                </li>
                <li>
                    сохранение скорости работы алгоритма, близкой к скорости работы
                    соответствующей хэш-функции;
                </li>
                <li>
                    возможность применения ключей и простота работы с ними.
                </li>
            </ul>
            <p>
                В алгоритме <em>НМАС</em> хэш-функция представляет собой "черный ящик".
                Это, во-первых, позволяет использовать существующие реализации хэш-функций,
                а во-вторых, обеспечивает легкую замену существующей хэш-функции на новую.
            </p>
            <p>
                Введем следующие обозначения:

            <ul>
                <li>
                    Н - встроенная хэш-функция.
                </li>
                <li>
                    b - длина блока используемой хэш-функции.
                </li>
                <li>
                    n - длина хэш-кода.
                </li>
                <li>
                    K - секретный ключ. К этому ключу слева добавляют нули,
                    чтобы получить b-битовый ключ K<sup>+</sup>.
                </li>
            </ul>
            </p>

            <p>
                Вводится два вспомогательных значения:

            <ul>
                <li>
                    Ipad - значение '00110110', повторенное b/8 раз.
                </li>
                <li>
                    Opad - значение '01011010', повторенное b/8 раз.
                </li>
            </ul>
            </p>
            <p>
                Далее <em>НМАС</em> вычисляется следующим образом:
                НМАС = Н ((K<sup>+</sup> ⊕
                Opad) || H ((K<sup>+</sup> ⊕
                Ipad) || M))
            </p>
            </p>
            <a href="../lk11/lk11.html">Следующая лекция - Цифровая подпись
            </a>
        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
