<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top; /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%; /* Ширина первой колонки */
    }

    #col2 {
        width: 80%; /* Ширина второй колонки */
    }

    #col3 {
        width: 10%; /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>ЛЕКЦИЯ 3</strong>
            </h3>
            <p align="center">
                <strong style="font-size: 18px">ТЕМА 3 - Алгоритмы симметричного шифрования</strong>
            </p>
            <p>
                <strong style="font-size: 17px"> 3.1. Основные понятия и определения</strong>
            </p>
            <p>
                Рассмотрим общую схему симметричного шифрования.
            </p>
            <p align="center">
                <img
                        src="../../images/lk3/1.png"
                        alt="Общая схема симметричного шифрования"
                />

            </p>
            <p align="center">
                <br/>
                Рисунок 3.1 – Схема симметричного шифрования
            </p>
            <p>
                <strong>Симметричные алгоритмы</strong>
                можно классифицировать на:
            </p>
            <ol>
            <li>
                <em>Моно- и многоалфавитные подстановки. </em>
            </li>
            <li>
                <em>Перестановки </em>
            </li>
            <li>
                <em>Гаммирование. </em>
            </li>
            <li>
                <em>Блочные шифры. </em>
            </li>
            </ol>
            <p>
                Алгоритмы симметричного шифрования различаются способом, которым
                обрабатывается исходный текст. Возможно шифрование блоками или шифрование
                потоком.
            </p>
            <p>
                Все действия, производимые над данными блочным криптоалгоритмом, основаны
                на том факте, что преобразуемый блок может быть представлен в виде целого
                неотрицательного числа из диапазона, соответствующего его разрядности. Так,
                например, 32-битный блок данных можно интерпретировать как число из
                диапазона 0..4'294'967'295. Кроме того, блок, разрядность которого обычно
                является "степенью двойки", можно трактовать как несколько независимых
                неотрицательных чисел из меньшего диапазона (рассмотренный выше 32-битный
                блок можно также представить в виде 2 независимых чисел из диапазона
                0..65535 или в виде 4 независимых чисел из диапазона 0..255).
            </p>
            <p>
                <a name="keyword-context.5"></a>
                Над этими числами блочным криптоалгоритмом и производятся по определенной
                схеме следующие действия:
            </p>
            <ul>
                <li>
                    Биективные математические функции (cложение, исключающее ИЛИ, умножение
                    по модулю 2<sup>N</sup>+1, умножение по модулю 2<sup>N</sup>);
                </li>
            <li>
                Битовые сдвиги (арифметические и циклические сдвиги влево и вправо);
            </li>
                <li>
                    Табличные подстановки.
                </li>
            </ul>
            <p>
                Описанные выше операции циклически повторяются в алгоритме, образуя так
                называемые <em>раунды</em>. Входом каждого <em>раунда</em> является выход
                предыдущего <em>раунда</em> и ключ, который получен по определенному
                алгоритму из ключа шифрования K. Ключ <em>раунда</em> называется <em>подключом</em>.
                Каждый алгоритм шифрования
                может быть представлен следующим образом:
            </p>
            <p align="center">
                <a name="image.2.2"></a>
                <img
                        src="../../images/lk3/3.png"
                        alt="Структура алгоритма симметричного шифрования"
                />
            </p>
            <p align="center">
                <br/>
                Рисунок 3.2 – Структура алгоритма симметричного шифрования
            </p>
            <p>
                <a name="sect3"></a>
                <strong></strong>
            </p>
            <p>
                Характерным признаком блочных алгоритмов является многократное и косвенное
                использование материала ключа. Это диктуется в первую очередь требованием
                невозможности обратного декодирования в отношении ключа при известных
                исходном и зашифрованном текстах. Для решения этой задачи в приведенных
                выше преобразованиях чаще всего используется не само значение ключа или его
                части, а некоторая, иногда необратимая (небиективная) функция от материала
                ключа. Более того, в подобных преобразованиях один и тот же блок или
                элемент ключа используется многократно. Это позволяет при выполнении
                условия обратимости функции относительно величины X сделать функцию
                необратимой относительно ключа Key.
            </p>
            <p>
                Поскольку операция зашифровки или расшифровки отдельного блока в процессе
                кодирования пакета информации выполняется многократно (иногда до сотен
                тысяч раз), а значение ключа и, следовательно, функций <em>Vi</em>(Key)
                остается неизменным, то иногда становится целесообразно заранее однократно
                вычислить данные значения и хранить их в оперативной памяти совместно с
                ключом. Поскольку эти значения зависят только от ключа, то они в
                криптографии называются материалом ключа. Необходимо отметить, что данная
                операция никоим образом не изменяет ни длину ключа, ни криптостойкость
                алгоритма в целом. Здесь происходит лишь оптимизация скорости вычислений
                путем кеширования (англ. caching) промежуточных результатов. Описанные
                действия встречаются практически во многих блочных криптоалгоритмах и носят
                название расширение ключа (англ. key scheduling).
            </p>
            <p>
                <strong></strong>
            </p>
            <p>
                <strong>Области применения</strong>
            </p>
            <p>
                Стандартный алгоритм шифрования должен быть применим во многих приложениях:
            </p>
            <ul type="disc">
                <li>
                    Шифрование данных.
                </li>
                <li>
                    Создание случайных чисел.
                </li>
                <li>
                    Хэширование.
                </li>
            </ul>
            <p>
                <a name="sect4"></a>
                <strong>Платформы</strong>
            </p>
            <p>
                Стандартный алгоритм шифрования должен быть реализован на различных
                платформах:
            </p>
            <ul type="disc">
                <li>
                    Специализированная аппаратура.
                </li>
                <li>
                    Большие процессоры.
                </li>
                <li>
                    Процессоры среднего размера.
                </li>
                <li>
                    Малые процессоры.
                </li>
            </ul>
            <p>
                <strong>Используемые критерии при разработке алгоритмов</strong>
            </p>
            <p>
                Считается, что алгоритм симметричного шифрования должен:
            </p>
            <ul>
                <li>
                    Иметь размер блока 64 или 128 бит.
                </li>
            <li>
                Иметь масштабируемый ключ до 256 бит.
            </li>
            <li>
                Использовать простые операции, которые эффективны на микропро­цессорах,
                Не должно использоваться сдвигов переменной длины, побитных перестановок
                или условных переходов.
            </li>
            <li>
                Должна быть возможность реализации алгоритма на 8-битном про­цессоре с
                минимальными требованиями к памяти.
            </li>
            <li>
                Использовать заранее вычисленные подключи.
            </li>
            <li>
                Состоять из переменного числа итераций.
            </li>
            <li>
                По возможности не иметь слабых ключей.
            </li>
            <li>
                Задействовать подключи, которые являются односторонним хэшем ключа.
            </li>
            <li>
                Не иметь линейных структур, которые уменьшают комплексность и не
                обеспечивают исчерпывающий поиск.
            </li>
            <li>
                Использовать простую для понимания разработку.
            </li>
            </ul>

            <br clear="all"/>
            <p>
                <strong style="font-size: 17px"> 3.2. Сеть Фейштеля</strong>
            </p>
            <p>
                Блочный алгоритм преобразовывает n-битный блок незашифрованного текста в
                n-битный блок зашифрованного текста. Число блоков длины n равно 2 <sup>n</sup>. Для того чтобы
                преобразование было обратимым, каждый из таких
                блоков должен преобразовываться в свой уникальный блок зашифрованного
                текста. При маленькой длине блока такая подстановка плохо скрывает
                статистические особенности незашифрованного текста. Если блок имеет длину
                64 бита, то он уже хорошо скрывает статистические особенности исходного
                текста. Но в данном случае преобразование текста не может быть произвольным
                в силу того, что ключом будет являться само преобразование, что исключает
                эффективную как программную, так и аппаратную реализации.
            </p>
            <p>
                Наиболее широкое распространение получили сети Фейштеля, так как, с одной
                стороны, они удовлетворяют всем требованиям к алгоритмам симметричного
                шифрования, а с другой стороны, достаточно просты и компактны.
            </p>
            <p>
                Сеть Фейштеля имеет следующую структуру. Входной блок делится на несколько
                равной длины подблоков, называемых ветвями. В случае, если блок имеет длину
                64 бита, используются две ветви по 32 бита каждая. Каждая ветвь
                обрабатывается независимо от другой, после чего осуществляется циклический
                сдвиг всех ветвей влево. Такое преобразование выполняется несколько циклов
                или раундов. В случае двух ветвей каждый раунд имеет структуру, показанную
                на рис 3.2.
            </p>
            <p align="center">
                <img
                        src="../../images/lk3/4.png"
                        alt="Feistel"
                />
            </p>
            <p align="center">
                Рисунок 3.2 –I-ый раунд сети Фейштеля
            </p>
            <p>
                Каждый раунд состоит из вычисления функции <em>F</em> для одной ветви и
                побитового выполнения операции XOR результата <em>F</em> с другой ветвью.
                После этого ветви меняются местами. Считается, что оптимальное число
                раундов – от 8 до 32. Важно то, что увеличение количества раундов
                значительно увеличивает криптостойкость алгоритма. Возможно, эта
                особенность и повлияла на столь активное распространение сети Фейштеля, так
                как для большей криптостойкости достаточно просто увеличить количество
                раундов, не изменяя сам алгоритм. В последнее время количество раундов не
                фиксируется, а лишь указываются допустимые пределы.
            </p>
            <p>
                Сеть Фейштеля является обратимой даже в том случае, если функция <em>F</em>
                не является таковой, так как для расшифрования не требуется вычислять
                <em>F</em><em><sup>-1</sup></em>.<em> </em>Для расшифрования используется
                тот же алгоритм, но на вход подается зашифрованный текст, и ключи
                используются в обратном порядке.
            </p>
            <p>
                Достоинства сети Фейштеля:
            </p>
            <ul>
            <li>
                процедуры шифрования и расшифрования совпадают, с тем исключением, что
                ключевая информация при расшифровании используется в обратном порядке;
            </li>
            <li>
                хорошая изученность алгоритмов на основе сетей Фейштеля;
            </li>
            <li>
                для построения устройств шифрования можно использовать те же блоки в
                цепях шифрования и расшифрования.
            </li>
            </ul>
            <p>
                Недостатком является то, что на каждой итерации изменяется только половина
                блока обрабатываемого текста, что приводит к необходимости увеличивать
                число итераций для достижения требуемой стойкости.
            </p>
            <p>
                В настоящее время все чаще используются различные разновидности сети
                Фейштеля для 128-битного блока с четырьмя ветвями. Увеличение количества
                ветвей, а не размерности каждой ветви связано с тем, что наи­более
                популярными до сих пор остаются процессоры с 32-разрядными словами,
                следовательно, оперировать 32-разрядными словами эффективнее, чем с
                64-разрядными.
            </p>
            <p>
                Основной характеристикой алгоритма, построенного на основе сети Фейштеля,
                является функция <em>F</em>. Различные варианты касаются также на­чального
                и конечного преобразований. Подобные преобразования, назы­ваемые
                забеливанием (whitening), осуществляются для того, чтобы вы­полнить
                начальную рандомизацию входного текста.
            </p>
            <br clear="all"/>
            <p>
                <strong style="font-size: 17px">3.3. Дифференциальный и линейный криптоанализ</strong>
            </p>
            <p>
                Понятие <em>дифференциального криптоанализа</em> было введено Эли Бихамом
                (Biham) и Ади Шамиром (Shamir) в 1990 году. Конечная задача <strong><em>дифференциального
                криптоанализа</em></strong> - используя
                свойства алгоритма, в основном свойства <em>S-box</em>, определить<em>подключ</em> <em>раунда</em>.
                Конкретный способ <em>дифференциального криптоанализа</em> зависит от рассматриваемого
                алгоритма шифрования.
            </p>
            <p>
                Если в основе алгоритма лежит <em>сеть Фейштеля</em>, то можно считать, что
                блок m состоит из двух половин - m<sub>0</sub> и m<sub>1</sub>. <em>Дифференциальный криптоанализ</em>
                рассматривает отличия, которые
                происходят в каждой половине при шифровании. (Для алгоритма <em>DES</em>
                "отличия" определяются с помощью операции XOR, для других алгоритмов
                возможен иной способ). Выбирается пара незашифрованных текстов с
                фиксированным отличием. Затем анализируются отличия, получившиеся после
                шифрования одним <em>раундом</em> алгоритма, и определяются вероятности
                различных ключей. Если для многих пар входных значений, имеющих одно и то
                же отличие Х, при использовании одного и того же <em>подключа</em>
                одинаковыми (Y) оказываются и отличия соответствующих выходных значений, то
                можно говорить, что Х влечет Y с определенной вероятностью. Если эта
                вероятность близка к единице, то можно считать, что <em>подключ</em> <em>раунда</em> найден с данной
                вероятностью. Так как <em>раунды</em>
                алгоритма независимы, вероятности определения <em>подключа</em> каждого <em>раунда</em> следует
                перемножать. Как мы помним, считается, что
                результат шифрования данной пары известен. Результаты <em>дифференциального криптоанализа</em>
                используются как при разработке
                конкретных <em>S-box</em>, так и при определении оптимального числа <em>раундов</em>.
            </p>
            <p>
                Другим способом криптоанализа является <em>линейный криптоанализ</em>,
                который использует линейные приближения преобразований, выполняемых
                алгоритмом шифрования. Данный метод позволяет найти ключ, имея достаточно
                большое число пар (незашифрованный текст, зашифрованный текст). Рассмотрим
                основные принципы, на которых базируется <em>линейный криптоанализ</em>.
                Обозначим
            </p>
            <table border="0" cellspacing="1" cellpadding="0">
                <tbody>
                <tr>
                    <td width="532" colspan="2" valign="top">
                        <p>
                            P[1], … , P[n] - незашифрованный блок сообщения.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="532" colspan="2" valign="top">
                        <p>
                            C[1], … , C[n] - зашифрованный блок сообщения.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td valign="top">
                        <p>
                            K[1], … , K[m] - ключ.
                        </p>
                    </td>
                    <td width="115">
                    </td>
                </tr>
                <tr>
                    <td valign="top">
                        <p>
                            A[i, j, …, k] = A[i] ⊕
                            A[j] ⊕ … ⊕ A[k]
                        </p>
                    </td>
                    <td width="115">
                    </td>
                </tr>
                </tbody>
            </table>
            <p>
                Целью <em>линейного криптоанализа</em> является поиск линейного уравнения
                вида
            </p>
            <p>
                P[α<sub>1</sub>, α<sub> 2</sub>, …, α<sub> </sub><sub>a</sub>] ⊕
                C[β<sub>1</sub>, β<sub>2</sub>, …, β<sub>b</sub> ] = K[γ<sub>1</sub>, …, γ <sub>c</sub>]
            </p>
            <p>
                Выполняющееся с вероятностью р &lt;&gt; 0.5. α<sub> i</sub>, β<sub>i</sub>
                и γ<sub>i</sub> - фиксированные позиции в блоках сообщения и ключе. Чем
                больше р отклоняется от 0.5, тем более подходящим считается уравнение.
            </p>
            <p>
                Это уравнение означает, что если выполнить операцию XOR над некоторыми
                битами незашифрованного сообщения и над некоторыми битами зашифрованного
                сообщения, получится бит, представляющий собой XOR некоторых битов ключа.
                Это называется линейным приближением, которое может быть верным с
                вероятностью р.
            </p>
            <p>
                Уравнения составляются следующим образом. Вычисляются значения левой части
                для большого числа пар соответствующих фрагментов незашифрованного и
                зашифрованного блоков. Если результат оказывается равен нулю более чем в
                половине случаев, то полагают, что K[γ<sub>1</sub>, …, γ<sub>с</sub>] = 0.
                Если в большинстве случаев получается 1, полагают, что K[γ<sub>1</sub>, …,
                γ<sub>с</sub>] = 1. Таким образом получают систему уравнений, решением
                которой является ключ.
            </p>
            <br clear="all"/>
            <p>
                <strong style="font-size: 17px">3.4. Алгоритм DES</strong>
            </p>
            <p>
                Самым распространенным и наиболее известным алгоритмом симметричного
                шифрования является <em>DES</em> (Data
                Encryption Standard). Алгоритм был разработан в 1977 году, в 1980 году был
                принят NIST (National Institute of Standards and Technology США) в качестве
                стандарта (FIPS PUB 46).
            </p>
            <p>
                <em>DES </em>
                является классической <em>сетью Фейстеля</em> с двумя ветвями. Данные
                шифруются 64-битными блоками, используя 56-битный ключ. Алгоритм
                преобразует за несколько <em>раундов </em>64-битный вход в 64-битный выход.
                Длина ключа равна 56 битам. Процесс шифрования состоит из четырех этапов.
                На первом из них выполняется начальная перестановка (<em>IP</em>)
                64-битного исходного текста (забеливание), во время которой биты
                переупорядочиваются в соответствии со стандартной таблицей. Следующий этап
                состоит из 16 <em>раундов</em> одной и той же функции, которая использует
                операции сдвига и подстановки. На третьем этапе левая и правая половины
                выхода последней (16-й) итерации меняются местами. Наконец,на четвертом
                этапе выполняется перестановка IP<sup>-1</sup> результата, полученного на
                третьем этапе. Перестановка IP<sup>-1</sup> инверсна начальной
                перестановке.
            </p>
            <p align="center">
                <img
                        src="../../images/lk3/5.png"
                        alt="Общая схема DES"
                />
            </p>
            <p align="center">
                Рисунок 3.3 – Общая схема DES
            </p>
            <p>
                <strong>Шифрование</strong>
            </p>
            <p>
                <strong>Начальная перестановка</strong>
            </p>
            <p>
                Начальная перестановка и ее инверсия определяются стандартной таблицей.
                Если М- это произвольные 64 бита, то X = IP (M)-переставленные 64 бита.
                Если применить обратную функцию перестановки Y = IP<sup>-1</sup> (X) = IP <sup>-1</sup> (IP(M)), то
                получится первоначальная последовательность бит.
            </p>
            <p>
                <strong>Последовательность преобразований отдельного раунда</strong>
            </p>
            <p>
                Теперь рассмотрим последовательность преобразований, используемую в каждом <em>раунде</em>.
            </p>
            <p align="center">
                <a name="image.2.5"></a>
                <img
                        src="../../images/lk3/6.png"
                        alt="I-ый раунд DES"
                />
            </p>
            <p align="center">
                <br/>
                Рисунок 3.4 –I-ый раунд DES
            </p>
            <p>
                64-битный входной блок проходит через 16 <em>раундов</em>, при этом на
                каждой итерации получается промежуточное 64-битное значение. Левая и правая
                части каждого промежуточного значения трактуются как отдельные 32-битные
                значения, обозначенные <em>L</em> и <em>R</em>. Каждую итерацию можно
                описать следующим образом:
            </p>
            <p>
                L<sub>i</sub> = R<sub>i-1</sub>
            </p>
            <p>
                R<sub>i</sub> = L<sub>i</sub><sub>-1</sub>⊕
                F(R<sub>i</sub><sub>-1</sub>, K<sub>i</sub>)
            </p>
            <p>
                Где ⊕ обозначает операцию XOR.
            </p>
            <p>
                Таким образом, выход левой половины <em>L<sub>i</sub></em> равен входу
                правой половины <em>R<sub>i-1</sub></em>. Выход правой половины <em>R<sub>i</sub></em><sub> </sub>является
                результатом применения операции
                XOR к <em>L<sub>i-1</sub> </em>и функции <em>F</em>, зависящей от <em>R<sub>i-1</sub> </em>и
                <em>K<sub>i</sub></em>.
            </p>
            <p>
                Рассмотрим функцию <em>F</em> более подробно.
            </p>
            <p>
                <em>R<sub>i</sub></em>
                , которое подается на вход функции <em>F</em>, имеет длину 32 бита. Вначале
                R<sub>i </sub>расширяется до 48 бит, используя таблицу, которая определяет
                перестановку плюс расширение на 16 бит. Расширение происходит следующим
                образом. 32 бита разбиваются на группы по 4 бита и затем расширяются до 6
                бит, присоединяя крайние биты из двух соседних групп. Например, если часть
                входного сообщения
            </p>
            <p>
                . . . efgh ijkl mnop . . .
            </p>
            <p>
                то в результате расширения получается сообщение
            </p>
            <p>
                . . . defghi hijklm lmnopq . . .
            </p>
            <p>
                После этого для полученного 48-битного значения выполняется операция XOR с
                48-битным <em>подключом </em><em>K<sub>i</sub></em>. Затем полученное
                48-битное значение подается на вход функции подстановки, результатом
                которой является 32-битное значение.
            </p>
            <p>
                Подстановка состоит из восьми <em>S-boxes,</em>каждый из которых на входе
                получает 6 бит, а на выходе создает 4 бита. Эти преобразования определяются
                специальными таблицами. Первый и последний биты входного значения <em>S-box </em>определяют номер строки
                в таблице, средние 4 бита определяют
                номер столбца. Пересечение строки и столбца определяет 4-битный выход.
                Например, если входом является 011011, то номер строки равен 01 (строка 1)
                и номер столбца равен 1101 (столбец 13). Значение в строке 1 и столбце 13
                равно 5, т.е. выходом является 0101.
            </p>
            <p>
                Далее полученное 32-битное значение обрабатывается с помощью перестановки <em>Р</em>, целью которой
                является максимальное переупорядочивание бит,
                чтобы в следующем <em>раунде</em> шифрования с большой вероятностью каждый
                бит обрабатывался другим <em>S-box</em>.
            </p>
            <p>
                <strong>Создание подключей</strong>
            </p>
            <p>
                Ключ для отдельного <em>раунда </em><em>K<sub>i</sub></em><sub> </sub>
                состоит из 48 бит. Ключи <em>K<sub>i</sub></em> получаются по следующему
                алгоритму. Для 56-битного ключа,используемого на входе алгоритма, вначале
                выполняется перестановка в соответствии с таблицей Permuted Choice 1
                (РС-1). Полученный 56-битный ключ разделяется на две 28-битные части,
                обозначаемые как C<sub>0</sub> и D<sub>0</sub> соответственно. На каждом
                <em>раунде </em><em>C<sub>i</sub></em> и <em>D<sub>i</sub></em><sub> </sub>
                независимо циклически сдвигаются влево на 1 или 2 бита, в зависимости от
                номера <em>раунда</em>. Полученные значения являются входом следующего <em>раунда</em>. Они также
                представляют собой вход в Permuted Choice 2
                (РС-2), который создает 48-битное выходное значение, являющееся входом
                функции <em>F</em>(<em>R<sub>i-1</sub></em>, <em>K<sub>i</sub></em>).
            </p>
            <p>
                <strong>Дешифрование</strong>
            </p>
            <p>
                Процесс дешифрования аналогичен процессу шифрования. На входе алгоритма
                используется зашифрованный текст, но ключи <em>K<sub>i</sub></em>
                используются в обратной последовательности. <em>K<sub>16</sub></em>
                используется на первом <em>раунде</em>, <em>K<sub>1</sub></em> используется
                на последнем <em>раунде</em>.
            </p>
            <p>
                <strong>Проблемой DES </strong>
                является малая длина ключа. Также без ответа пока остается вопрос, возможен
                ли криптоанализ с использованием существующих характеристик алгоритма<em>DES</em>. Основой алгоритма
                являются восемь таблиц подстановки, или <em>S-boxes</em>, которые применяются в каждой итерации.
                Существует
                опасность, что эти <em>S-boxes</em> конструировались таким образом, что
                криптоанализ возможен для взломщика, который знает слабые места <em>S-boxes</em>. В течение многих лет
                обсуждалось как стандартное, так и
                неожиданное поведение <em>S-boxes</em>, но все-таки никому не удалось
                обнаружить их фатально слабые места.
            </p>
            <p>
                <strong>Двойной DES</strong>
            </p>
            <p>
                Простейший способ увеличить длину ключа состоит в повторном применении <em>DES</em> с двумя разными
                ключами. Используя незашифрованное сообщение P
                и два ключа K<sub>1</sub> и K<sub>2</sub>, зашифрованное сообщение С можно
                получить следующим образом:
            </p>
            <p>
                C = E<sub>k2</sub> [E<sub>k1</sub> [P]]
            </p>
            <p>
                При дешифрования два ключа применяются в обратном порядке:
            </p>
            <p>
                P = D<sub>k1</sub> [D<sub>k2</sub> [C]]
            </p>
            <p>
                В этом случае длина ключа равна 56 * 2 = 112 бит.
            </p>
            <p>
                <strong>Атака "встреча посередине"</strong>
            </p>
            <p>
                Для приведенного выше алгоритма двойного <em>DES</em> существует так
                называемая атака "встреча посередине". Она основана на следующем свойстве
                алгоритма. Мы имеем
            </p>
            <p>
                С = E<sub>k2</sub> [E<sub>k1</sub> [P]]
            </p>
            <p>
                Тогда
            </p>
            <p>
                X = E<sub>k1</sub> [P] = D<sub>k2</sub> [C].
            </p>
            <p>
                Атака состоит в следующем. Требуется, чтобы атакующий знал хотя бы одну
                пару незашифрованный текст и соответствующий ему зашифрованный текст: (Р,
                С). В этом случае, во-первых, шифруется Р для всех возможных 2<sup>56</sup>
                значений K<sub>1</sub>. Этот результат запоминается в таблице, и затем
                таблица упорядочивается по значению Х. Следующий шаг состоит в дешифровании
                С, с применением всех возможных 2<sup>56</sup> значений K<sub>2</sub>. Для
                каждого выполненного дешифрования ищется равное ему значение в первой
                таблице. Если соответствующее значение найдено, то считается, что эти ключи
                могут быть правильными, и они проверяются для следующей известной пары
                незашифрованный текст, зашифрованный текст.
            </p>
            <p>
                <strong>Тройной DES с двумя ключами</strong>
            </p>
            <p>
                Очевидное противодействие атаке "встреча посередине" состоит в
                использовании третьей стадии шифрования с тремя различными ключами. Это
                поднимает стоимость лобовой атаки до 2<sup>168</sup>, которая на
                сегодняшний день считается выше практических возможностей. Но при этом
                длина ключа равна 56 * 3 = 168 бит, что иногда бывает громоздко.
            </p>
            <p>
                В качестве альтернативы предлагается метод тройного шифрования,использующий
                только два ключа. В этом случае выполняется последовательность
                зашифрование-расшифрование-зашифрование (EDE).
            </p>
            <p align="center">
                C = E<sub>K1</sub> [D<sub>K2</sub> [E<sub>K1</sub> [P]]]
            </p>
            <p align="center">
                <a name="image.2.6"></a>
                <img
                        src="../../images/lk3/7.png"
                        alt="Шифрование тройным DES"
                />
            </p>
            <p align="center">
                Рисунок 3.5 – Шифрование тройным DES
            </p>
            <p align="center">
                <br/>
                <a name="image.2.7"></a>
                <img
                        src="../../images/lk3/8.png"
                        alt="Дешифрование тройным DES"
                />
            </p>
            <p align="center">
                Рисунок 3.6 – Дешифрование тройным DES
            </p>
            <p>
                <br/>
                Не имеет большого значения, что используется на второй стадии: шифрование
                или дешифрование. В случае использования дешифрования существует только то
                преимущество, что можно <em>тройной DES</em> свести к обычному одиночному <em>DES</em>, используя K<sub>1</sub>
                = K<sub>2</sub>:
            </p>
            <p align="center">
                C = E<sub>K1</sub> [D<sub>K1</sub> [E<sub>K1</sub> [P]]] = E<sub>K1</sub>
                [P]
            </p>
            <p>
                Известных криптографических атак на <em>тройной DES</em> не существует.
                Цена подбора ключа в <em>тройном DES</em> равна 2<sup>112</sup>.
            </p>
            <br clear="all"/>
            <p>
                <strong style="font-size: 17px">
                    3.5. Алгоритм Blowfish </strong>
            </p>
            <p>
                <a name="keyword-context.1"></a>
                <strong><em>Blowfish</em></strong>
                является сетью Фейштеля, у которой количество итераций равно 16. Длина
                блока равна 64 битам, ключ может иметь любую длину в пределах 448 бит. Хотя
                перед началом любого шифрования выполняется сложная фаза инициализации,
                само шифрование данных выполняется достаточно быстро.
            </p>
            <p>
                Алгоритм предназначен в основном для приложений, в которых ключ меняется
                нечасто, к тому же существует фаза начального рукопожатия, во время которой
                происходит аутентификация сторон и согласование общих параметров и
                секретов. Классическим примером подобных приложений является сетевое
                взаимодействие. При реализации на 32-битных микропроцессорах с большим
                кэшем данных <em>Blowfish</em> значительно быстрее DES.
            </p>
            <p>
                Алгоритм состоит из двух частей: расширение ключа и шифрование данных.
                Расширение ключа преобразует ключ длиной, по крайней мере, 448 бит в
                несколько массивов <em>подключей</em> общей длиной 4168 байт.
            </p>
            <p>
                В основе алгоритма лежит сеть Фейштеля с 16 итерациями. Каждая итерация
                состоит из перестановки, зависящей от ключа, и подстановки, зависящей от
                ключа и данных. Операциями являются XOR и сложение 32-битных слов.
            </p>
            <p>
                <em>Blowfish</em>
                использует большое количество <em>подключей</em>. Эти ключи должны быть
                вычислены заранее, до начала любого шифрования или дешифрования данных.
                Элементы алгоритма:
            </p>
            <p>
                1. Р - массив, состоящий из восемнадцати 32-битных <em>подключей</em>:
            </p>
            <p>
                Р<sub>1</sub>, Р<sub>2</sub>, ..., Р<sub>18</sub>.
            </p>
            <p>
                2. Четыре 32-битных <em>S-boxes</em> c 256 входами каждый. Первый индекс
                означает номер <em>S-box</em>, второй индекс - номер входа.
            </p>
            <p>
                S<sub>1,0</sub>, S<sub>1,1</sub>, … S<sub>1,255</sub>;
            </p>
            <p>
                S<sub>2,0</sub>, S<sub>2,1</sub>, … S<sub>2,255</sub>;
            </p>
            <p>
                S<sub>3,0</sub>, S<sub>3,1</sub>, … S<sub>3,255</sub>;
            </p>
            <p>
                S<sub>4,0</sub>, S<sub>4,1</sub>, … S<sub>4,255</sub>;
            </p>
            <p>
                Метод, используемый для вычисления этих <em>подключей</em>, будет описан
                ниже.
            </p>
            <br clear="all"/>
            <p>
                <strong></strong>
            </p>
            <p>
                <strong>Шифрование</strong>
            </p>
            <p>
                Входом является 64-битный элемент данных X, который делится на две
                32-битные половины, X<sub>l</sub> и X<sub>r</sub>.<strong>(</strong> <strong>L</strong><strong>
                и </strong><strong>R</strong><strong>) </strong>
                (рис. 3.7).
            </p>
            <p align="center">
                <img
                        src="../../images/lk3/9.jpg"
                />
            </p>
            <p align="center">
                Рисунок 3.7 – Шифрование/дешифрование Blowfish
            </p>
            <p>
                X<sub>l</sub> = X<sub>l</sub> XOR P<sub>i</sub>
            </p>
            <p>
                X<sub>r</sub> = F (X<sub>l</sub>) XOR X<sub>r</sub>
            </p>
            <p>
                Swap X<sub>l</sub> and X<sub>r</sub>
            </p>
            <p>
                <strong>Функция </strong>
                <strong>F</strong>
                <strong></strong>
            </p>
            <p>
                Разделить X<sub>l</sub> на четыре 8-битных элемента A, B, C, D.
            </p>
            <p>
                F (X<sub>l</sub>) = ((S<sub>1,</sub><sub>А</sub> + S<sub>2,B</sub> mod 2 <sup>32</sup>) XOR
                S<sub>3,C</sub>) + S<sub>4,D</sub> mod 2<sup>32</sup>
            </p>
            <p>
                Дешифрование отличается от шифрования тем, что P<sub>i</sub> используются в
                обратном порядке.
            </p>
            <p>
                <strong>Генерация подключей</strong>
            </p>
            <p>
                <em>Подключи</em>
                вычисляются с использованием самого <em>алгоритма Blowfish</em>.
            </p>
            <ol>
            <li>
                Инициализировать первый Р-массив и четыре <em>S-boxes</em> фиксированной
                строкой.
            </li>
            <li>
                Выполнить операцию XOR P<sub>1</sub> с первыми 32 битами ключа, операцию
                XOR P<sub>2</sub> со вторыми 32 битами ключа и т.д. Повторять цикл до тех
                пор, пока весь Р-массив не будет побитово сложен со всеми битами ключа. Для
                коротких ключей выполняется конкатенация ключа с самим собой.
            </li>
            <li>
                Зашифровать нулевую строку <em>алгоритмом Blowfish</em>, используя <em>подключи</em>, описанные в
                пунктах (1) и (2).
            </li>
            <li>
                Заменить Р<sub>1</sub> и Р<sub>2</sub> выходом, полученным на шаге (3).
            </li>
            <li>
                Зашифровать выход шага (3), используя <em>алгоритм Blowfish</em> с
                модифицированными <em>подключами</em>.
            </li>
            <li>
                Заменить Р<sub>3</sub> и Р<sub>4</sub> выходом, полученным на шаге (5).
            </li>
            <li>
                Продолжить процесс, заменяя все элементы Р-массива, а затем все четыре<em>S-boxes</em>, выходами
                соответствующим образом модифицированного <em>алгоритма Blowfish</em>.
                <p>
                    Для создания всех <em>подключей</em> требуется 521 итерация.
                </p>
            </li>
            </ol>

            <a href="../lk4/lk4.html">Следующая лекция - Алгоритмы симметричного шифрования <em>(продолжение)</em> </a>
        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
