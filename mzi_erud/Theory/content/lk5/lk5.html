<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>

<style type="text/css">
    TD {
        vertical-align: top; /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%; /* Ширина первой колонки */
    }

    #col2 {
        width: 80%; /* Ширина второй колонки */
    }

    #col3 {
        width: 10%; /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>ЛЕКЦИЯ 5</strong>
            </h3>
            <p align="center">
                <strong style="font-size: 18px">ТЕМА 4 - Разработка Advanced Encryption Standard (AES)</strong>
            </p>
            <p>
                <strong style="font-size: 17px"> 4.1. Режимы выполнения методов симметричного шифрования</strong>
            </p>

            <p>
                Для любого симметричного блочного алгоритма шифрования определено четыре
                режима выполнения.
            </p>
            <p>
                <strong><em>ECB</em></strong>
                - Electronic Codebook - каждый блок из 64 битов незашифрованного текста
                шифруется независимо от остальных блоков, с применением одного и того же <em>ключа шифрования</em>.
                Типичные приложения - безопасная передача
                одиночных значений.
            </p>
            <p>
                <strong><em>CBC</em></strong>
                - Cipher Block Chaining - вход криптографического алгоритма является
                результатом применения операции XOR к следующему блоку незашифрованного
                текста и предыдущему блоку зашифрованного текста. Типичные приложения -
                общая блокоориентированная передача.
            </p>
            <p>
                <strong><em>CFB</em></strong>
                - Cipher Feedback - при каждом вызове алгоритма обрабатывается J битов
                входного значения. Предшествующий зашифрованный блок используется в
                качестве входа в алгоритм; к J битам выхода алгоритма и следующему
                незашифрованному блоку из J битов применяется операция XOR, результатом
                которой является следующий зашифрованный блок из J битов. Типичные
                приложения - потокоориентированная передача, аутентификация.
            </p>
            <p>
                <strong><em>OFB</em></strong>
                - Output Feedback - аналогичен <em>CFB</em>, за исключением того, что на
                вход алгоритма при шифровании следующего блока подается результат
                шифрования предыдущего блока; только после этого выполняется операция XOR с
                очередными J битами незашифрованного текста. Типичные приложения -
                потокоориентированная передача по зашумленному каналу (например,
                спутниковая связь).
            </p>
            <br>
            <p>
                <strong style="font-size: 17px">
                    4.2. Алгоритмы создания случайных чисел </strong>
            </p>
            <p>
                Большинство алгоритмов сетевой безопасности, основанных на криптографии,
                используют случайные числа. Например:
            </p>
            <ol>
            <li>
                 Схемы взаимной аутентификации.
            </li>
            <li>
                Ключ сессии, созданный KDC или кем-либо из участников.
            </li>
            </ol>
            <p>
                Двумя основными требованиями к последовательности случайных чисел являются <em>случайность</em> и <em>непредсказуемость</em>.
            </p>
            <p>
                Шифрующие приложения используют для создания случайных чисел специальные
                алгоритмы. Эти алгоритмы детерминированы и, следовательно, создают
                последовательность чисел, которая не является статистически случайной. Тем
                не менее, если алгоритм хороший, полученная последовательность будет
                проходить много тестов на случайность. Такие числа часто называют <em>псевдослучайными числами</em>.
            </p>
            <p>
                <strong>Генераторы псевдослучайных чисел</strong>
            </p>
            <p>
                Первой широко используемой технологией создания случайного числа был
                алгоритм, предложенный Лехмером, который известен как метод линейного
                конгруента. Этот алгоритм параметризуется четырьмя числами следующим
                образом:
            </p>
            <div align="center">
                <table border="1" cellspacing="1" cellpadding="0">
                    <tbody>
                    <tr>
                        <td width="97">
                            <p>
                                <strong>M</strong>
                            </p>
                        </td>
                        <td valign="top">
                            <p>
                                Модуль (основание системы)
                            </p>
                        </td>
                        <td width="132" valign="top">
                            <p>
                                m &gt; 0
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td width="97">
                            <p>
                                <strong>A</strong>
                            </p>
                        </td>
                        <td valign="top">
                            <p>
                                Множитель
                            </p>
                        </td>
                        <td width="132" valign="top">
                            <p>
                                0 ≤ a &lt; m
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td width="97">
                            <p>
                                <strong>C</strong>
                            </p>
                        </td>
                        <td valign="top">
                            <p>
                                Приращение
                            </p>
                        </td>
                        <td width="132" valign="top">
                            <p>
                                0 ≤ с &lt; m
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td width="97">
                            <p>
                                <strong>Х<sub>0</sub></strong>
                            </p>
                        </td>
                        <td valign="top">
                            <p>
                                Начальное значение или зерно (seed)
                            </p>
                        </td>
                        <td width="132" valign="top">
                            <p>
                                0 ≤ Х<sub>0</sub> &lt; m
                            </p>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
            <p>
                Последовательность случайных чисел {X<sub>n</sub>} получается с помощью
                следующего итерационного равенства:
            </p>
            <p>
                X<sub>n+1</sub> = (a X<sub>n</sub> + c) mod m
            </p>
            <p>
                Если m, а и с являются целыми, то создается последовательность целых чисел
                в диапазоне 0 ≤ X<sub>n</sub> &lt; m.
            </p>
            <p>
                Существует три критерия, используемые при выборе генератора случайных
                чисел:
            </p>
            <ol>
            <li>
                Функция должна создавать полный период, т.е. все числа между 0 и m до
                того, как создаваемые числа начнут повторяться.
            </li>
            <li>
                Создаваемая последовательность должна появляться случайно.
                Последовательность не является случайной, так как она создается
                детерминированно, но различные статистические тесты, которые могут
                применяться, должны показывать, что последовательность случайна.
            </li>
            <li>
                Функция должна эффективно реализовываться на 32-битных процессорах.
            </li>
            </ol>
            <p>
                Значения а, с и m должны быть выбраны таким образом, чтобы эти три критерия
                выполнялись. В соответствии с первым критерием можно показать, что если m
                является простым и с = 0, то при определенном значении а период,
                создаваемый функцией, будет равен m-1. Для 32-битной арифметики
                соответствующее простое значение m = 2<sup>31</sup> - 1. Таким образом,
                функция создания <em>псевдослучайных чисел</em> имеет вид:
            </p>
            <p>
                X<sub>n+1</sub> = (a X<sub>n</sub>) mod (2<sup>31</sup> - 1)
            </p>
            <p>
                Сила алгоритма линейного конгруента в том, что если сомножитель и модуль
                (основание) соответствующим образом подобраны, то результирующая
                последовательность чисел будет статистически неотличима от
                последовательности, являющейся случайной из набора 1, 2, ..., m-1. Но не
                может быть случайности в последовательности, полученной с использованием
                алгоритма, независимо от выбора начального значения Х<sub>0</sub>. Если
                значение выбрано, то оставшиеся числа в последовательности будут
                предопределены. Это всегда учитывается при криптоанализе.
            </p>
            <p>
                Если противник знает, что используется алгоритм линейного конгруента, и
                если известны его параметры (а = 7<sup>5</sup>, с = 0, m = 2<sup>31</sup> -
                1), то, если раскрыто одно число, вся последовательность чисел становится
                известна. Даже если противник знает только, что используется алгоритм
                линейного конгруента, знания небольшой части последовательности достаточно
                для определения параметров алгоритма и всех последующих чисел. Предположим,
                что противник может определить значения Х<sub>0</sub>, Х<sub>1</sub>, Х <sub>2</sub>, Х<sub>3</sub>.
                Тогда :
            </p>
            <p>
                Х<sub>1</sub> = (а Х<sub>0</sub> + с ) mod m
            </p>
            <p>
                Х<sub>2</sub> = (а Х<sub>1</sub> + с ) mod m
            </p>
            <p>
                Х<sub>3</sub> = (а Х<sub>2</sub> + с ) mod m
            </p>
            <p>
                Эти равенства позволяют найти а, с и m.
            </p>
            <p>
                Таким образом, хотя алгоритм и является хорошим генератором <em>псевдослучайной последовательности
                чисел</em>, желательно, чтобы
                реально используемая последовательность была непредсказуемой, поскольку в
                этом случае знание части последовательности не позволит определить будущие
                ее элементы. Эта цель может быть достигнута несколькими способами.
                Например, использование внутренних системных часов для модификации потока
                случайных чисел. Один из способов применения часов состоит в перезапуске
                последовательности после N чисел, используя текущее значение часов по
                модулю m в качестве нового начального значения. Другой способ состоит в
                простом добавлении значения текущего времени к каждому случайному числу по
                модулю m.
            </p>
            <p>
                <strong>Криптографически созданные случайные числа</strong>
            </p>
            <p>
                В криптографических приложениях целесообразно шифровать получающиеся
                случайные числа. Чаще всего используется три способа.
            </p>
            <p>
                <strong><em>Циклическое шифрование</em></strong>
            </p>
            <p align="center">
                <a name="image.3.14"></a>
                <img
                        src="../../images/lk5/1.png"
                        alt="Циклическое шифрование"
                />
            </p>
            <p align="center">
                Рисунок 4.1 – Циклическое шифрование
            </p>
            <p>
                В данном случае применяется способ создания ключа сессии из мастер-ключа.
                Счетчик с периодом N используется в качестве входа в шифрующее устройство.
                Например, в случае использования 56-битного ключа DES может применяться
                счетчик с периодом 2<sup>56</sup>. После каждого созданного ключа значение
                счетчика увеличивается на 1. Таким образом, псевдослучайная
                последовательность, полученная по данной схеме, имеет полный период: каждое
                выходное значение Х<sub>0</sub>, Х<sub>1</sub>,...Х<sub>N-1</sub> основано
                на различных значениях счетчика и, следовательно, Х<sub>0</sub> ≠
                X<sub>1</sub> ≠
                X<sub>N-1</sub>. Так как мастер-ключ защищен, легко показать, что любой
                секретный ключ не зависит от знания одного или более предыдущих секретных
                ключей.
            </p>
            <p>
                <strong><em>Режим Output Feedback DES</em></strong>
            </p>
            <p>
                Режим <em>OFB</em> DES может применяться для генерации ключа, аналогично
                тому, как он используется для потокового шифрования. Заметим, что выходом
                каждой стадии шифрования является 64-битное значение, из которого только
                левые j битов подаются обратно для шифрования. 64-битные выходы составляют
                последовательность <em>псевдослучайных чисел</em> с хорошими
                статистическими свойствами.
            </p>
            <p>
                <strong><em>Генератор псевдослучайных чисел ANSI X9.17</em></strong>
            </p>
            <p>
                Один из наиболее сильных генераторов <em>псевдослучайных чисел</em> описан
                в ANSI X9.17. В число приложений, использующих эту технологию, входят
                приложения финансовой безопасности и PGP.
            </p>
            <p>
                Алгоритмом шифрования является тройной DES. Генератор ANSI X9.17 состоит из
                следующих частей:
            </p>
            <ol>
            <li>
                <strong>Вход:</strong> генератором управляют два псевдослучайных входа.
                Один является 64-битным представлением текущих даты и времени, которые
                изменяются каждый раз при создании числа. Другой является 64-битным
                начальным значением; оно инициализируется некоторым произвольным значением
                и изменяется в ходе генерации последовательности <em>псевдослучайных чисел</em>.
            </li>
            <li>
                <strong>Ключи:</strong> генератор использует три модуля тройного DES.
                Все три используют одну и ту же пару 56-битных ключей, которая должна
                держаться в секрете и применяться только для генерации <em>псевдослучайного числа</em>.
            </li>
            <li>
                <strong>Выход:</strong> выход состоит из 64-битного <em>псевдослучайного числа</em> и 64-битного
                значения, которое будет
                использоваться в качестве начального значения при создании следующего
                числа.
            </li>
            </ol>
            <p align="center">
                <a name="image.3.15"></a>
                <img
                        src="../../images/lk5/2.png"
                        alt="Генератор псевдослучайных чисел ANSI X9.17"
                />
            </p>
            <p align="center">
                Рисунок 4.2 – Генератор псевдослучайных чисел ANSI X9.17
            </p>
            <table border="0" cellspacing="1" cellpadding="0">
                <tbody>
                <tr>
                    <td width="566" valign="top">
                        <p>
                            DT<sub>i</sub> - значение даты и времени на начало i-ой
                            стадии генерации.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="566" valign="top">
                        <p>
                            V<sub>i</sub> - начальное значение для i-ой стадии
                            генерации.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="566" valign="top">
                        <p>
                            R<sub>i</sub> - <em>псевдослучайное число</em>, созданное
                            на i-ой стадии генерации.
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="566" valign="top">
                        <p>
                            K<sub>1</sub>, K<sub>2</sub> - ключи, используемые на
                            каждой стадии.
                        </p>
                    </td>
                </tr>
                </tbody>
            </table>
            <p>
                Тогда:
            </p>
            <p>
                R<sub>i</sub> = EDE<sub>K1,K2</sub> [ EDE<sub>K1,K2</sub> [ DT<sub>i</sub>] ⊕
                V<sub>i</sub> ]
            </p>
            <p>
                V<sub>i+1</sub> = EDE<sub>K1,K2</sub> [ EDE<sub>K1,K2</sub> [ DT <sub>i</sub>] R<sub>i</sub>]
            </p>
            <p>
                Схема включает использование 112-битного ключа и трех EDE-шифрований. На
                вход подаются два <em>псевдослучайных значения</em>: значение даты и
                времени и начальное значение очередной итерации, на выходе создаются
                начальное значение для следующей итерации и очередное <em>псевдослучайное значение</em>. Даже если <em>псевдослучайное
                число</em>
                R<sub>i</sub> будет скомпрометировано, вычислить V<sub>i+1</sub> из R<sub>i</sub> невозможно, и,
                следовательно, следующее<em>псевдослучайное значение</em> R<sub>i+1</sub>, так как для получения V <sub>i+1</sub>
                дополнительно выполняются три операции EDE.
            </p>

            <a href="../lk6/lk6.html">Следующая лекция - Разработка Advanced Encryption Standard <em>(продолжение)</em> </a>
        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
