<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top; /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%; /* Ширина первой колонки */
    }

    #col2 {
        width: 80%; /* Ширина второй колонки */
    }

    #col3 {
        width: 10%; /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>ЛЕКЦИЯ 9</strong>
            </h3>
            <p align="center">
                <strong style="font-size: 18px">ТЕМА 6 - Хэш-функции</strong>
            </p>
            <p>
                <strong style="font-size: 17px">6.1. Требования к хэш-функциям</strong>
            </p>
            <p>
                <em>Хэш-функцией</em>
                называется односторонняя функция, предназначенная для получения <em>дайджеста</em> или "отпечатков
                пальцев" файла, сообщения или некоторого
                блока данных.
            </p>
            <p>
                <em>Хэш-код</em>
                создается функцией Н: h = H (M)
            </p>
            <p>
                Где М является сообщением произвольной длины и h является <em>хэш-кодом</em> фиксированной длины.
            </p>
            <p>
                <em>Хэш-функция</em>
                Н, которая используется для аутентификации сообщений, должна обладать
                следующими свойствами:
            </p>
            <ol>
                <li>
                    <em>Хэш-функция</em> Н должна применяться к блоку данных любой длины.
                </li>
                <li>
                    <em>Хэш-функция</em> Н создает выход фиксированной длины.
                </li>
                <li>
                    Н (М) относительно легко (за полиномиальное время) вычисляется для
                    любого значения М.
                </li>
                <li>
                    Для любого данного значения <em>хэш-кода</em> h вычислительно невозможно
                    найти M такое, что Н (M) = h.
                </li>
                <li>
                    Для любого х вычислительно невозможно найти y ≠ x, что H (y) = H (x).
                </li>
                <li>
                    Вычислительно невозможно найти произвольную пару (х, y) такую, что H (y)
                    = H (x).
                </li>
            </ol>
            <br/>
            <p>
                <strong style="font-size: 17px">6.2. Простые хэш-функции</strong>
            </p>
            <p>
                Все <em>хэш-функции</em> выполняются следующим образом. Входное значение
                (сообщение, файл и т.п.) рассматривается как последовательность n-битных
                блоков. Входное значение обрабатывается последовательно блок за блоком, и
                создается m-битное значение <em>хэш-кода</em>.
            </p>
            <p>
                Одним из простейших примеров <em>хэш-функции</em> является побитный XOR
                каждого блока:
            </p>
            <p>
                С<sub>i</sub> = b<sub>i1</sub> ⊕
                b<sub>i2</sub> ⊕
                ... ⊕
                b<sub>ik</sub>
            </p>
            <p>
                Где
            <ul>
                <li>
                    С<sub>i</sub> - i-ый бит <em>хэш-кода</em>, 1≤i≤n.
                </li>
                <li>
                    k - число n-битных блоков входа.
                </li>
                <li>
                    b<sub>ij</sub> - i-ый бит в j-ом блоке.
                </li>
                <li>
                    ⊕ - операция XOR.
                </li>

            </ul>
            </p>

            <p>
                В результате получается <em>хэш-код</em> длины n, известный как продольный
                избыточный контроль. Это эффективно при случайных сбоях для проверки
                целостности данных.
            </p>
            <p>
                Часто при использовании подобного продольного избыточного контроля для
                каждого блока выполняется однобитный циклический сдвиг после вычисления <em>хэш-кода</em>. Это можно
                описать следующим образом.
            </p>
            <ul type="disc">
                <li>
                    Установить n-битный <em>хэш-код</em> в ноль.
                </li>
                <li>
                    Для каждого n-битного блока данных выполнить следующие операции:
                </li>
                <ul type="circle">
                    <li>
                        сдвинуть циклически текущий <em>хэш-код</em> влево на один бит;
                    </li>
                    <li>
                        выполнить операцию XOR для очередного блока и <em>хэш-кода</em>.
                    </li>
                </ul>
            </ul>
            <p>
                Это даст эффект "случайности" входа и уничтожит любую регулярность, которая
                присутствует во входных значениях.
            </p>
            <p>
                Хотя второй вариант считается более предпочтительным для обеспечения
                целостности данных и предохранения от случайных сбоев, он не может
                использоваться для обнаружения преднамеренных модификаций передаваемых
                сообщений. Зная сообщение, атакующий легко может создать новое сообщение,
                которое имеет тот же самый <em>хэш-код</em>. Для этого следует подготовить
                альтернативное сообщение и затем присоединить n-битный блок, который
                является <em>хэш-кодом</em> нового сообщения, и блок, который является <em>хэш-кодом</em> старого
                сообщения.
            </p>
            <p>
                Хотя простого XOR или ротационного XOR (RXOR) недостаточно, если
                целостность обеспечивается только зашифрованным <em>хэш-кодом</em>, а само
                сообщение не шифруется, подобная простая функция может использоваться,
                когда все сообщение и присоединенный к нему <em>хэш-код</em> шифруются. Но
                и в этом случае следует помнить о том, что подобная <em>хэш-функция</em> не
                может проследить за тем, чтобы при передаче последовательность блоков не
                изменилась. Это происходит в силу того, что данная <em>хэш-функция</em>
                определяется следующим образом: для сообщения, состоящего из
                последовательности 64-битных блоков Х<sub>1</sub>, Х<sub>2</sub>,..., Х <sub>N</sub>, определяется <em>хэш-код</em>
                С как поблочный XOR всех
                блоков, который присоединяется в качестве последнего блока:
            </p>
            <p>
                С = Х<sub>N+1</sub> = X<sub>1</sub> ⊕
                X<sub>2</sub> ⊕
                . . . ⊕
                X<sub>N</sub>
            </p>
            <p>
                Затем все сообщение шифруется, включая <em>хэш-код</em>, в режиме СВС для
                создания зашифрованных блоков Y<sub>1</sub>, Y<sub>2</sub>, ..., Y <sub>N+1</sub>. По определению СВС
                имеем:
            </p>
            <ol>
                <li>
                    Х<sub>1</sub> = IV ⊕
                    D<sub>K</sub> [Y<sub>1</sub>]
                </li>
                <li>
                    Х<sub>i</sub> = Y<sub>i-1</sub> ⊕
                    D<sub>K</sub> [Y<sub>i</sub>]
                </li>
                <li>
                    Х<sub>N+1</sub> = Y<sub>N</sub> ⊕
                    D<sub>K</sub> [Y<sub>N+1</sub>]. Но X<sub>N+1</sub> является <em>хэш-кодом</em>:
                </li>

                <li>
                    Х<sub>N+1</sub> = X<sub>1</sub> ⊕
                    X<sub>2</sub> ⊕
                    ... ⊕
                    X<sub>N</sub> = (IV ⊕
                    D<sub>K</sub> [Y<sub>1</sub>]) ⊕
                    (Y<sub>1</sub> ⊕
                    D<sub>K</sub> [Y<sub>2</sub>]) ⊕
                    ... ⊕
                    (Y<sub>N-1</sub> ⊕
                    D<sub>K</sub> [Y<sub>N</sub>])
                </li>
            </ol>

            <p>
                Так как сомножители в предыдущем равенстве могут вычисляться в любом
                порядке, следовательно, <em>хэш-код</em> не будет изменен, если
                зашифрованные блоки будут переставлены.
            </p>
            <br/>
            <p>
                <strong style="font-size: 17px">6.3. Парадокс дня рождения</strong>
            </p>
            <p>
                Предположим, количество выходных значений <em>хэш-функции</em> <em>Н</em>
                равно <em>n</em>. Каким должно быть число <em>k</em>, чтобы для конкретного
                значения <em>X</em> и значений <em>Y<sub>1</sub></em>, …,<em>Y<sub>k</sub></em> вероятность того, что
                хотя бы для одного <em>Y<sub>i</sub></em> выполнялось равенство
            </p>
            <p>
                H (X) = H (Y) была бы больше 0,5.
            </p>
            <p>
                Для одного <em>Y</em> вероятность того, что <em>H</em> (<em>X</em>) = <em>H</em> (<em>Y</em>), равна
                1/<em>n</em>.
            </p>
            <p>
                Соответственно, вероятность того, что <em>H</em>(<em>X</em>) ≠ <em>H</em>( <em>Y</em>), равна 1 - 1/<em>n</em>.
            </p>
            <p>
                Если создать <em>k</em> значений, то вероятность того, что ни для одного из
                них не будет совпадений, равна произведению вероятностей, соответствующих
                одному значению, т.е. (1 - 1/<em>n</em>)<sup>k</sup>.
            </p>
            <p>
                Следовательно, вероятность, по крайней мере, одного совпадения равна
            </p>
            <p>
                1 - (1 - 1/n)<sup>k</sup>
            </p>
            <p>
                По формуле бинома Ньютона
            </p>
            <p>
                (1 - a)<sup>k</sup> = 1 - ka + (k(k-1)/2!)a<sup>2</sup> - ... ≈ 1 - ka
            </p>
            <p>
                1 - (1 - k/n) = k/n = 0,5
            </p>
            <p>
                k = n/2
            </p>
            <p>
                Таким образом, мы выяснили, что для m-битового <em>хэш-кода</em> достаточно
                выбрать 2<sup>m-1</sup> сообщений, чтобы вероятность совпадения <em>хэш-кодов</em> была больше 0,5.
            </p>
            <p>
                Теперь рассмотрим следующую задачу: обозначим P (n, k) вероятность того,
                что в множестве из k элементов, каждый из которых может принимать n
                значений, есть хотя бы два с одинаковыми значениями. Чему должно быть равно
                k, чтобы P (n, k) была бы больше 0,5?
            </p>
            <p>
                Число различных способов выбора элементов таким образом, чтобы при этом не
                было дублей, равноn(n-1) … (n-k+1)n!/(n-k)!
            </p>
            <p>
                Всего возможных способов выбора элементов равно n<sup>k</sup>
            </p>
            <p>
                Вероятность того, что дублей нет, равна n!/(n-k)!n<sup>k</sup>
            </p>
            <p>
                Вероятность того, что есть дубли, соответственно равна 1 - n!/(n-k)!n <sup>k</sup>
            </p>
            <p>
                P (n, k) = 1 - n! / ((n-k)! × n<sup>k</sup>) = 1 - (n × (n-1) × … ×
                (n-k-1)) / n<sup>k</sup> =
            </p>
            <p>
                1 - [ (n-1)/n × … × (n-k+1)/n] = 1 - [(1- 1/n) × (1 - 2/n) × … × (1 -
                (k-1)/n)]
            </p>
            <p>
                Известно, что 1 - x ≤ e<sup>-</sup><sup>x</sup>
            </p>
            <p>
                P (n, k) &gt; 1 - [e<sup>-1/n</sup> × e<sup>-2</sup>/n × … × e<sup>-k</sup>
                /n]
            </p>
            <p>
                P (n, k) &gt; 1 - e<sup>-k(k-1)/n</sup>
            </p>
            <p>
                1/2 = 1 - e<sup>-k(k-1)/n</sup>
            </p>
            <p>
                2 = e<sup>k(k-1)/n</sup>
            </p>
            <p>
                ln 2 = k (k-1) / 2n
            </p>
            <p>
                k (k-1) ≈ k<sup>2</sup>
            </p>
            <p>
                k = (2n × ln 2)<sup>1/2</sup> = 1,17 n<sup>1/2</sup> ≈ n<sup>1/2</sup>
            </p>
            <p>
                Если <em>хэш-код</em> имеет длину m бит, т.е. принимает 2<sup>m</sup>
                значений, то
            </p>
            <p>
                k = √2m = 2<sup>m/2</sup>
            </p>
            <p>
                Подобный результат называется "парадоксом дня рождения", потому что в
                соответствии с приведенными выше рассуждениями для того, чтобы вероятность
                совпадения дней рождения у двух человек была больше 0,5, в группе должно
                быть всего 23 человека. Этот результат кажется удивительным, возможно,
                потому, что для каждого отдельного человека в группе вероятность того, что
                с его днем рождения совпадет день рождения кого-то другого в группе,
                достаточно мала.
            </p>
            <p>
                Вернемся к рассмотрению свойств <em>хэш-функций</em>. Предположим, что
                используется 64-битный <em>хэш-код</em>. Можно считать, что это вполне
                достаточная и, следовательно, безопасная длина для <em>хэш-кода</em>.
                Например, если зашифрованный <em>хэш-код</em> С передается с
                соответствующим незашифрованным сообщением М, то противнику необходимо
                будет найти М' такое, что
            </p>
            <p>
                Н (М') = Н (М)
            </p>
            <p>
                для того, чтобы подменить сообщение и обмануть получателя. В среднем
                противник должен перебрать 2<sup>63</sup> сообщений для того, чтобы найти
                такое, у которого <em>хэш-код</em> равен перехваченному сообщению.
            </p>
            <p>
                Тем не менее, возможны различного рода атаки, основанные на "парадоксе дня
                рождения". Возможна следующая стратегия:
            </p>
            <ol>
                <li>
                    Противник создает 2<sup>m/2</sup> вариантов сообщения, каждое из которых
                    имеет некоторый определенный смысл. Противник подготавливает такое же
                    количество сообщений, каждое из которых является поддельным и предназначено
                    для замены настоящего сообщения.
                </li>
                <li>
                    Два набора сообщений сравниваются в поисках пары сообщений, имеющих
                    одинаковый <em>хэш-код</em>. Вероятность успеха в соответствии с
                    "парадоксом дня рождения" больше, чем 0,5. Если соответствующая пара не
                    найдена, то создаются дополнительные исходные и поддельные сообщения до тех
                    пор, пока не будет найдена пара.
                </li>
                <li>
                    Атакующий предлагает отправителю исходный вариант сообщения для подписи.
                    Эта подпись может быть затем присоединена к поддельному варианту для
                    передачи получателю. Так как оба варианта имеют один и тот же <em>хэш-код</em>, будет создана
                    одинаковая
                    подпись. Противник будет уверен
                    в успехе, даже не зная ключа шифрования.
                </li>
            </ol>
            <br/>
            <p>
                <strong style="font-size: 17px">6.4. Использование цепочки зашифрованных блоков</strong>
            </p>
            <p>
                Существуют различные <em>хэш-функции</em>, основанные на создании цепочки
                зашифрованных блоков, но без использования секретного ключа. Одна из таких <em>хэш-функций</em> была
                предложена Рабином. Сообщение М разбивается на
                блоки фиксированной длины М<sub>1</sub>, М<sub>2</sub>, . . . , М <sub>N</sub> и используется алгоритм
                симметричного шифрования, например
                DES, для вычисления <em>хэш-кода</em> G следующим образом:
            </p>
            <ul>
                <li>
                    Н<sub>0</sub> = начальное значение
                </li>
                <li>
                    Н<sub>i</sub> = E<sub>Mi</sub> [H<sub>i</sub><sub>-1</sub>]
                </li>
                <li>
                    G = H<sub>N</sub>
                </li>
            </ul>

            <p>
                Это аналогично использованию шифрования в режиме СВС, но в данном случае
                секретного ключа нет. Как и в случае любой <em>простой хэш-функции</em>,
                этот алгоритм подвержен "атаке дня рождения", и если шифрующим алгоритмом
                является DES и создается только 64-битный <em>хэш-код</em>, то система
                считается достаточно уязвимой.
            </p>
            <p>
                Могут осуществляться другие атаки типа "дня рождения", которые возможны
                даже в том случае, если противник имеет доступ только к одному сообщению и
                соответствующему ему зашифрованному <em>хэш-коду</em> и не может получить
                несколько пар сообщений и зашифрованных <em>хэш-кодов</em>. Возможен
                следующий сценарий: предположим, что противник перехватил сообщение с
                аутентификатором в виде зашифрованного <em>хэш-кода</em>, и известно, что
                незашифрованный <em>хэш-код</em> имеет длину m битов. Далее противник
                должен выполнить следующие действия:
            </p>
            <ul type="disc">
                <li>
                    Используя описанный выше алгоритм, вычислить незашифрованный <em>хэш-код</em> G.
                </li>
                <li>
                    Создать поддельное сообщение в виде Q<sub>1</sub>, Q<sub>2</sub>, . . .
                    , Q<sub>N-2</sub>. <br/> Вычислить Н<sub>i</sub> = E<sub>Qi</sub>[H<sub>i-1</sub>] для 1 ≤ i ≤ N-2.
                </li>
                <li>
                    Создать 2<sup>m/2</sup> случайных блока Х и для каждого такого блока Х
                    вычислить Е<sub>Х</sub>[H<sub>N-2</sub>]. Создать дополнительно 2<sup>m/2</sup> cлучайных блока Y и
                    для каждого блока Y вычислить D <sub>Y</sub>[G], где D - дешифрующая функция, соответствующая Е.
                    Основываясь на "парадоксе дня рождения" можно сказать, что с высокой
                    степенью вероятности эта последовательность будет содержать блоки Х и Y
                    такие, что Е<sub>Х</sub>[<sub>HN-2</sub>] = D<sub>Y</sub>[Y].
                </li>
                <li>
                    Создать сообщение Q<sub>1</sub>, Q<sub>2</sub>, . . . ,Q<sub>N-2</sub>,
                    X, Y. Это сообщение имеет <em>хэш-код</em> G и, следовательно, может
                    быть использовано вместе с зашифрованным аутентификатором.
                </li>
            </ul>
            <p>
                Эта форма атаки известна как атака "встреча посередине". В различных
                исследованиях предлагаются более тонкие методы для усиления подхода,
                основанного на цепочке блоков. Например, Девис и Прайс описали следующий
                вариант: H<sub>i</sub> = E<sub>Mi</sub> [H<sub>i-1</sub>] ⊕
                H<sub>i-1</sub>
            </p>
            <p>
                Возможен другой вариант: H<sub>i</sub> = E<sub>Hi-1</sub> [M<sub>i</sub>] ⊕
                M<sub>i</sub>
            </p>
            <p>
                Однако обе эти схемы также имеют уязвимости при различных атаках. В более
                общем случае, можно показать, что некоторая форма "атаки дня рождения"
                имеет успех при любом хэш-алгоритме, включающем использование цепочки
                шифрованных блоков без применения секретного ключа.
            </p>
            <p>
                Дальнейшие исследования были направлены на поиск других подходов к созданию
                функций хэширования.
            </p>
            <br clear="all"/>
            <p>
                <strong style="font-size: 17px">6.5. Хэш-функция MD5</strong>
            </p>
            <p>
                Алгоритм MD5 получает на входе сообщение произвольной длины и создает в
                качестве выхода <em>дайджест сообщения</em> длиной 128 бит. Алгоритм
                состоит из следующих шагов:
            </p>
            <p align="center">
                <a name="image.8.1"></a>
                <img
                        width="450"
                        height="171"
                        src="../../images/lk9/1.png"
                        alt="Логика выполнения MD5"
                />
            </p>
            <p align="center">
                <br/>
                Рисунок 6.1 – Логика выполнения MD5
            </p>
            <p>
                <strong><em>Шаг 1: добавление недостающих битов</em></strong>
                <em></em>
            </p>
            <p>
                Сообщение дополняется таким образом, чтобы его длина стала равна 448 по
                модулю 512 (длина≡448 mod 512).
            </p>
            <p>
                <strong><em>Шаг 2: добавление длины</em></strong>
                <em></em>
            </p>
            <p>
                64-битное представление длины исходного (до добавления) сообщения в битах
                присоединяется к результату первого шага. Если первоначальная длина больше,
                чем 2<sup>64</sup>, то используются только последние 64 бита.
            </p>
            <p align="center">
                <a name="image.8.2"></a>
                <img
                        width="400"
                        height="72"
                        src="../../images/lk9/2.png"
                        alt="Структура расширенного сообщения"
                />
            </p>
            <p align="center">
                Рисунок 6.2 – Структура расширенного сообщения
            </p>
            <p>
                <strong><em>Шаг 3: инициализация MD-буфера</em></strong>
                <em></em>
            </p>
            <p>
                Используется 128-битный буфер для хранения промежуточных и окончательных
                результатов <em>хэш-функции</em>. Буфер может быть представлен как четыре
                32-битных регистра (A, B, C, D). Эти регистры инициализируются следующими
                шестнадцатеричными числами:
            </p>
            <p>
                А = 01234567; В = 89ABCDEF; C = FEDCBA98; D = 76543210
            </p>
            <p>
                <strong>
                    <em>
                        Шаг 4: обработка последовательности 512-битных (16-словных) блоков
                    </em>
                </strong>
                <em></em>
            </p>
            <p>
                Основой алгоритма является модуль, состоящий из четырех циклических
                обработок, обозначенный как HMD5. Четыре цикла имеют похожую структуру, но
                каждый цикл использует свою элементарную логическую функцию, обозначаемую f <sub>F</sub>, f<sub>G</sub>,
                f<sub>H</sub> и f<sub>I</sub> соответственно.
            </p>
            <p align="center">
                <a name="image.8.3"></a>
                <img
                        src="../../images/lk9/3.png"
                        alt="Обработка очередного 512-битного блока"
                />
            </p>
            <p align="center">
                Рисунок 6.3 – Обработка очередного 512-битного блока
            </p>
            <p>
                Каждый цикл принимает в качестве входа текущий 512-битный блок Y <sub>q</sub>, обрабатывающийся в данный
                момент, и 128-битное значение
                буфера ABCD, которое является промежуточным значением <em>дайджеста</em>, и
                изменяет содержимое этого буфера. Каждый цикл также использует четвертую
                часть 64-элементной таблицы T[1 ... 64], построенной на основе функции sin.
                i-ый элемент T, обозначаемый T[i], имеет значение, равное целой части от 2 <sup>32</sup> * abs (sin
                (i)), i задано в радианах. Так как abs (sin (i))
                является числом между 0 и 1, каждый элемент Т является целым, которое может
                быть представлено 32 битами. Таблица обеспечивает "случайный" набор
                32-битных значений, которые должны ликвидировать любую регулярность во
                входных данных.
            </p>
            <p>
                Для получения MD<sub>q+1</sub> выход четырех циклов складывается по модулю
                2<sup>32</sup> с MD<sub>q</sub>. Сложение выполняется независимо для
                каждого из четырех слов в буфере.
            </p>
            <p>
                <strong><em>Шаг 5: выход</em></strong>
                <em></em>
            </p>
            <p>
                После обработки всех <em>L</em> 512-битных блоков выходом <em>L</em>-ой
                стадии является 128-битный <em>дайджест сообщения</em>.
            </p>
            <br/>
            <p>
                <strong style="font-size: 17px">6.6. Алгоритм MD4</strong>
            </p>
            <p>
                Кратко рассмотрим основные цели MD4:
            </p>
            <ol>
                <li>
                    Безопасность.
                </li>
                <li>
                    Скорость.
                </li>
                <li>
                    Простота и компактность.
                </li>
                <li>
                    Желательна little-endian архитектура.
                </li>
            </ol>

            <p>
                Эти цели преследовались и при разработке <em>MD5</em>. <em>MD5</em>
                является более сложным и, следовательно, более медленным при выполнении,
                чем MD4. Считается, что добавление сложности оправдывается возрастанием
                уровня безопасности. Главные различия между этими двумя алгоритмами состоят
                в следующем:
            </p>
            <ol>
                <li>
                    MD4 использует три цикла из 16 шагов каждый, в то время как <em>MD5</em>
                    использует четыре цикла из 16 шагов каждый.
                </li>
                <li>
                    В MD4 дополнительная константа в первом цикле не применяется.
                    Аналогичная дополнительная константа используется для каждого из шагов во
                    втором цикле. Другая дополнительная константа используется для каждого из
                    шагов в третьем цикле. В <em>MD5</em> различные дополнительные константы, Т
                    [i], применяются для каждого из 64 шагов.
                </li>
                <li>
                    <em>MD5</em> использует четыре элементарные логические функции, по одной
                    на каждом цикле, по сравнению с тремя в MD4, по одной на каждом цикле.
                </li>
                <li>
                    В <em>MD5</em> на каждом шаге текущий результат складывается с
                    результатом предыдущего шага. Например, результатом первого шага является
                    измененное слово А. Результат второго шага хранится в D и образуется
                    добавлением А к циклически сдвинутому влево на определенное число бит
                    результату элементарной функции. Аналогично, результат третьего шага
                    хранится в С и образуется добавлением D к циклически сдвинутому влево
                    результату элементарной функции. MD4 это последнее сложение не включает.
                </li>
            </ol>

            <br/>
            <p>
                <strong style="font-size: 17px">6.7. Хэш-функция SHA-1</strong>
            </p>
            <p>
                Алгоритм получает на входе сообщение максимальной длины 2<sup>64</sup> бит
                и создает в качестве выхода дайджест сообщения длиной 160 бит.
            </p>
            <p>
                Алгоритм состоит из следующих шагов:
            </p>
            <p align="center">
                <a name="image.9.1"></a>
                <img
                        src="../../images/lk9/4.png"
                        alt="Логика выполнения SHA-1"
                />
            </p>
            <p align="center">
                Рисунок 6.4 – Логика выполнения SHA-1
            </p>
            <p>
                <br/>
                <strong><em>Шаг 1: добавление недостающих битов</em></strong>
                <em></em>
            </p>
            <p>
                Сообщение добавляется таким образом, чтобы его длина была кратна 448 по
                модулю 512 (длина≡448 mod 512).
            </p>
            <p>
                <strong><em>Шаг 2: добавление длины</em></strong>
                <em></em>
            </p>
            <p>
                К сообщению добавляется блок из 64 битов. Этот блок трактуется как
                беззнаковое 64-битное целое и содержит длину исходного сообщения до
                добавления.
            </p>
            <p>
                <strong><em>Шаг 3: инициализация SHA-1 буфера</em></strong>
                <em></em>
            </p>
            <p>
                Используется 160-битный буфер для хранения промежуточных и окончательных
                результатов хэш-функции. Буфер может быть представлен как пять 32-битных
                регистров A, B, C, D и E. Эти регистры инициализируются следующими
                шестнадцатеричными числами:
            </p>
            <p>
                A = 67452301; B = EFCDAB89; C = 98BADCFE; D = 10325476; E = C3D2E1F0
            </p>
            <p>
                <strong>
                    <em>Шаг 4: обработка сообщения в 512-битных (16-словных) блоках</em>
                </strong>
                <em></em>
            </p>
            <p>
                Основой алгоритма является модуль, состоящий из 80 циклических обработок,
                обозначенный как H<sub>SHA</sub>. Все 80 циклических обработок имеют
                одинаковую структуру.
            </p>
            <p align="center">
                <a name="image.9.2"></a>
                <img
                        src="../../images/lk9/5.png"
                        alt="Обработка очередного 512-битного блока"
                />
            </p>
            <p align="center">
                Рисунок 6.5 – Обработка очередного 512-битного блока
            </p>
            <p>
                Каждый цикл получает на входе текущий 512-битный обрабатываемый блок Y <sub>q</sub> и 160-битное
                значение буфера ABCDE, и изменяет содержимое
                этого буфера.
            </p>
            <p>
                В каждом цикле используется дополнительная константа К<sub>t</sub>, которая
                принимает только четыре различных значения:
            </p>
            <p>
                0 ≤ t ≤ 19 K<sub>t</sub> = 5A827999 (целая часть числа [2<sup>30</sup> × 2 <sup>1/2</sup>])
            </p>
            <p>
                20 ≤ t ≤ 39 K<sub>t</sub> = 6ED9EBA1 (целая часть числа [2<sup>30</sup> × 3 <sup>1/2</sup>])
            </p>
            <p>
                40 ≤ t ≤ 59 K<sub>t</sub> = 8F1BBCDC (целая часть числа [2<sup>30</sup> × 5 <sup>1/2</sup>])
            </p>
            <p>
                60 ≤ t ≤ 79 K<sup>t</sup> = CA62C1D6 (целая часть числа [2<sup>30</sup> ×
                10<sup>1/2</sup>])
            </p>
            <p>
                Для получения SHA<sub>q+1</sub> выход 80-го цикла складывается со значением
                SHA<sub>q</sub>. Сложение по модулю 2<sup>32</sup> выполняется независимо
                для каждого из пяти слов в буфере с каждым из соответствующих слов в SHA <sup>q</sup>.
            </p>
            <p>
                <strong><em>Шаг 5: выход</em></strong>
                <em></em>
            </p>
            <p>
                После обработки всех 512-битных блоков выходом L-ой стадии является
                160-битный дайджест сообщения.
            </p>
            <p>
                Рассмотрим более детально логику в каждом из 80 циклов обработки одного
                512-битного блока. Каждый цикл можно представить в виде:
            </p>
            <p>
                A, B, C, D, E (CLS<sub>5</sub> (A) + f<sub>t</sub> (B, C, D) + E + W <sub>t</sub> + K<sub>t</sub>), A,
                CLS<sub>30</sub> (B), C, D
            </p>
            <p>
                Где
            </p>
            <ul>
                <li>
                    A, B, C, D, E - пять слов из буфера.
                </li>
                <li>
                    t - номер цикла, 0≤t≤79.
                </li>
                <li>
                    f<sub>t</sub> – элементарная логическая функция.
                </li>
                <li>
                    CLS<sub>s</sub> - циклический левый сдвиг 32-битного
                    аргумента на s битов.
                </li>
                <li>
                    W<sub>t</sub> - 32-битное слово, полученное из текущего
                    входного 512-битного блока.
                </li>
                <li>
                    K<sub>t</sub> - дополнительная константа.
                </li>
                <li>
                    + - сложение по модулю 2<sup>32</sup>.
                </li>
            </ul>

            <p align="center">
                <a name="image.9.3"></a>
                <img
                        src="../../images/lk9/6.png"
                        alt="Логика выполнения отдельного цикла"
                />
            </p>
            <p align="center">
                Рисунок 6.6 – Логика выполнения отдельного цикла
            </p>
            <p>
                Каждая элементарная функция получает на входе три 32-битных слова и создает
                на выходе одно 32-битное слово. Элементарная функция выполняет набор
                побитных логических операций, т.е. n-ый бит выхода является функцией от
                n-ых битов трех входов. Функции следующие:
            </p>
            <table border="1" cellspacing="1" cellpadding="0" align="center">
                <tbody>
                <tr>
                    <td width="263">
                        <p align="center">
                            <strong>Номер цикла</strong>
                        </p>
                    </td>
                    <td width="304">
                        <p align="center">
                            <strong>ft (B, C, D)</strong>
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="263" valign="top">
                        <p align="center">
                            (0≤t≤19)
                        </p>
                    </td>
                    <td width="304" valign="top">
                        <p align="center">
                            (B ⊕
                            C) ⊕
                            (¬ B ⊕
                            D)
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="263" valign="top">
                        <p align="center">
                            (20≤t≤39)
                        </p>
                    </td>
                    <td width="304" valign="top">
                        <p align="center">
                            B ⊕
                            C ⊕
                            D
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="263" valign="top">
                        <p align="center">
                            (40≤t≤59)
                        </p>
                    </td>
                    <td width="304" valign="top">
                        <p align="center">
                            (B ⊕
                            C) ⊕
                            (B ⊕
                            D) ⊕
                            (C ⊕
                            D)
                        </p>
                    </td>
                </tr>
                <tr>
                    <td width="263" valign="top">
                        <p align="center">
                            (60≤t≤79)
                        </p>
                    </td>
                    <td width="304" valign="top">
                        <p align="center">
                            B ⊕
                            C ⊕
                            D
                        </p>
                    </td>
                </tr>
                </tbody>
            </table>
            <p>
                32-битные слова W<sub>t</sub> получаются из очередного 512-битного блока
                сообщения следующим образом.
            </p>
            <p align="center">
                <a name="image.9.4"></a>
                <img
                        width="450"
                        height="163"
                        src="../../images/lk9/7.png"
                        alt="Получение входных значений каждого цикла из очередного блока"
                />
            </p>
            <p align="center">
                Рисунок 6.7 – Логика выполнения отдельного цикла
            </p>
            <p>
                Получение входных значений каждого цикла из очередного блока
            </p>
            <p>
                Первые 16 значений W<sub>t</sub> берутся непосредственно из 16 слов
                текущего блока. Оставшиеся значения определяются следующим образом:
            </p>
            <p>
                W<sub>t</sub> = W<sub>t</sub><sub>-16</sub> ⊕
                W<sub>t</sub><sub>-14</sub> ⊕
                W<sub>t</sub><sub>-8</sub> ⊕
                W<sub>t</sub><sub>-3</sub>
            </p>
            <p>
                В первых 16 циклах вход состоит из 32-битного слова данного блока. Для
                оставшихся 64 циклов вход состоит из XOR нескольких слов из блока
                сообщения.
            </p>
            <p>
                Алгоритм <em>SHA-1</em> можно суммировать следующим образом:
            </p>
            <p>
                SHA<sub>0</sub> = IV
            </p>
            <p>
                SHA<sub>q</sub><sub>+1</sub> = Σ32 (SHA<sub>q</sub> , ABCDE<sub>q</sub> )
            </p>
            <p>
                SHA = SHA<sub>L-1</sub>
            </p>
            <p>
                Где

            <ul>
                <li>
                    IV - начальное значение буфера ABCDE.
                </li>
                <li>
                    ABCDE<sub>q</sub> - результат обработки q-того блока
                    сообщения.
                </li>
                <li>
                    L - число блоков в сообщении, включая поля добавления и
                    длины.
                </li>
                <li>
                    Σ32 - сумма по модулю 2<sup>32</sup>, выполняемая отдельно
                    для каждого слова буфера.
                </li>
                <li>
                    SHA - значение дайджеста сообщения.
                </li>
            </ul>

            <br/>
            <p>
                <strong style="font-size: 17px">6.8. Хэш-функция SHA-2</strong>
            </p>
            <p>
                В 2001 году NIST принял в качестве стандарта три хэш-функции с существенно
                большей длиной хэш-кода. Часто эти хэш-функции называют <em>SHA-2</em> или
                SHA-256, SHA-384 и SHA-512 (соответственно, в названии указывается длина
                создаваемого ими хэш-кода). Эти алгоритмы отличаются не только длиной
                создаваемого хэш-кода, но и длиной обрабатываемого блока, длиной слова и
                используемыми внутренними функциями. Сравним характеристики этих
                хэш-функций.
            </p>
            <table border="1" cellspacing="1" cellpadding="0" align="center">
                <tbody>
                <tr>
                    <td>
                        <p align="center">
                            Алгоритм
                        </p>
                    </td>
                    <td>
                        <p align="center">
                            Длина сообщения
                        </p>
                        <p align="center">
                            (в битах)
                        </p>
                    </td>
                    <td>
                        <p align="center">
                            Длина блока
                        </p>
                        <p align="center">
                            (в битах)
                        </p>
                    </td>
                    <td width="89">
                        <p align="center">
                            Длина слова
                        </p>
                        <p align="center">
                            (в битах)
                        </p>
                    </td>
                    <td width="126">
                        <p align="center">
                            Длина дайджеста сообщения
                        </p>
                        <p align="center">
                            (в битах)
                        </p>
                    </td>
                    <td>
                        <p align="center">
                            Безопасность
                        </p>
                        <p align="center">
                            (в битах)
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            SHA-1
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            &lt;2<sup>64</sup>
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            512
                        </p>
                    </td>
                    <td width="89" valign="top">
                        <p align="center">
                            32
                        </p>
                    </td>
                    <td width="126" valign="top">
                        <p align="center">
                            160
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            80
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            SHA-256
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            &lt;2<sup>64</sup>
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            512
                        </p>
                    </td>
                    <td width="89" valign="top">
                        <p align="center">
                            32
                        </p>
                    </td>
                    <td width="126" valign="top">
                        <p align="center">
                            256
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            128
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            SHA-384
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            &lt;2<sup>128</sup>
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            1024
                        </p>
                    </td>
                    <td width="89" valign="top">
                        <p align="center">
                            64
                        </p>
                    </td>
                    <td width="126" valign="top">
                        <p align="center">
                            384
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            192
                        </p>
                    </td>
                </tr>
                <tr>
                    <td>
                        <p>
                            SHA-512
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            &lt;2<sup>128</sup>
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            1024
                        </p>
                    </td>
                    <td width="89" valign="top">
                        <p align="center">
                            64
                        </p>
                    </td>
                    <td width="126" valign="top">
                        <p align="center">
                            512
                        </p>
                    </td>
                    <td valign="top">
                        <p align="center">
                            256
                        </p>
                    </td>
                </tr>
                </tbody>
            </table>
            <p>
                Под безопасностью здесь понимается стойкость к атакам типа "парадокса дня
                рождения".
            </p>
            <p>
                В данных алгоритмах размер блока сообщения равен m бит. Для SHA-256 m =
                512, для SHA-384 и SHA-512 m = 1024. Каждый алгоритм оперирует с w-битными
                словами. Для SHA-256 w = 32, для SHA-384 и SHA-512 w = 64. В алгоритмах
                используются обычные булевские операции над словами, а также сложение по
                модулю 2<sup>w</sup>, правый сдвиг на n бит SHR<sup>n</sup> (x) , где х -
                w-битное слово, и циклические (ротационные) правый и левый сдвиги на n бит
                ROTR<sup>n</sup> (x) и ROTL<sup>n</sup> (x), где х - w-битное слово.
            </p>
            <p>
                SHA-256 использует шесть логических функций, при этом каждая из них
                выполняется с 32-битными словами, обозначенными как x, y и z. Результатом
                каждой функции тоже является 32-битное слово.
            </p>
            <p>
                Ch (x, y, z) = (x ⊕
                y) ⊕
                (¬x ⊕
                z)
            </p>
            <p>
                Maj (x, y, z) = (x ⊕
                y) ⊕
                (x ⊕
                z) ⊕
                (y ⊕
                z)
            </p>
            <p>
                Σ<sub>0</sub><sup>{256}</sup> (x) = ROTR<sup>2</sup> (x) ⊕
                ROTR<sup>13</sup> (x) ⊕
                ROTR<sup>22</sup> (x)
            </p>
            <p>
                Σ<sub>1</sub><sup>{256}</sup> (x) = ROTR<sup>6</sup> (x) ⊕
                ROTR<sup>11</sup> (x) ⊕
                ROTR<sup>25</sup> (x)
            </p>
            <p>
                σ<sub>0</sub><sup>{256}</sup> (x) = ROTR<sup>7</sup> (x) ⊕
                ROTR<sup>18</sup> (x) ⊕
                SHR<sup>3</sup> (x)
            </p>
            <p>
                σ<sub>1</sub><sup>{256}</sup> (x) = ROTR<sup>17</sup> (x) ⊕
                ROTR<sup>19</sup> (x) ⊕
                SHR<sup>10</sup> (x)
            </p>
            <p>
                SHA-384 и SHA-512 также используют шесть логических функций, каждая из
                которых выполняется над 64-битными словами, обозначенными как x, y и z.
                Результатом каждой функции является 64-битное слово.
            </p>
            <p>
                Ch (x, y, z) = (x ⊕
                y) ⊕
                (¬x ⊕
                z)
            </p>
            <p>
                Maj (x, y, z) = (x ⊕
                y) ⊕
                (x ⊕
                z) ⊕
                (y ⊕
                z)
            </p>
            <p>
                Σ<sub>0</sub><sup>{512}</sup> (x) = ROTR<sup>28</sup> (x) ⊕
                ROTR<sup>34</sup> (x) ⊕
                ROTR<sup>39</sup> (x)
            </p>
            <p>
                Σ<sub>1</sub><sup>{512}</sup> (x) = ROTR<sup>14</sup> (x) ⊕
                ROTR<sup>18</sup> (x) ⊕
                ROTR<sup>41</sup> (x)
            </p>
            <p>
                σ<sub>0</sub><sup>{512}</sup> (x) = ROTR<sup>1</sup> (x) ⊕
                ROTR<sup>8</sup> (x) ⊕
                SHR<sup>7</sup> (x)
            </p>
            <p>
                σ<sub>1</sub><sup>{512}</sup> (x) = ROTR<sup>19</sup> (x) ⊕
                ROTR<sup>61</sup> (x) ⊕
                SHR<sup>6</sup> (x)
            </p>
            <p>
                Предварительная подготовка сообщения, т.е. добавление определенных битов до
                целого числа блоков и последующее разбиение на блоки выполняется аналогично
                тому, как это делалось в <em>SHA-1</em> (конечно, с учетом длины блока
                каждой хэш-функции). После этого каждое сообщение можно представить в виде
                последовательности N блоков M<sup>(1)</sup>, M<sup>(2)</sup>, … , M <sup>(N)</sup>.
            </p>
            <p>
                Рассмотрим SHA-256. В этом случае инициализируются восемь 32-битных
                переменных, которые послужат промежуточным значением хэш-кода:
            </p>
            <p>
                a, b, c, d, e, f, g, h
            </p>
            <p>
                Основой алгоритма является модуль, состоящий из 64 циклических обработок
                каждого блока M<sup>(i)</sup>:
            </p>
            <p>
                T<sub>1</sub> = h + Σ<sub>1</sub><sup>{256}</sup>(e) + Ch(e, f, g) + K <sub>t</sub><sup>{256}</sup> +
                W<sub>t</sub>
            </p>
            <p>
                T<sub>2</sub> = Σ<sub>0</sub><sup>{256}</sup>(a) + Maj(a, b, c)
            </p>
            <p>
                h = g <br/>
                g = f <br/>
                f = e <br/>
                e = d + T<sub>1</sub> <br/>
                d = c <br/>
                c = b <br/>
                b = a <br/>
                a = T<sub>1</sub> + T<sub>2</sub> <br/>
            </p>
            <p>
                где K<sub>i</sub><sup>{256}</sup> - шестьдесят четыре 32-битных константы,
                каждая из которых является первыми 32-мя битами дробной части кубических
                корней первых 64 простых чисел.
            </p>
            <p>
                W<sub>t</sub> вычисляются из очередного блока сообщения по следующим
                правилам:
            </p>
            <p>
                W<sub>t</sub> = M<sub>t</sub><sup>(i)</sup> , 0 ≤ t ≤ 15
            </p>
            <p>
                W<sub>t</sub> = σ<sub>1</sub><sup>{256}</sup>(W<sub>t-2</sub>) + W<sub>t-7</sub> + σ<sub>0</sub><sup>{256}</sup>(W<sub>t-15</sub>)
                + W <sub>t-16</sub> , 16 ≤ t ≤ 63
            </p>
            <p>
                i-ое промежуточное значение хэш-кода H<sup>(t)</sup> вычисляется следующим
                образом:
            </p>
            <p>
                H<sub>0</sub><sup>(i)</sup> = a + H<sub>0</sub><sup>(i-1)</sup> <br/>
                H<sub>1</sub><sup>(i)</sup> = b + H<sub>1</sub><sup>(i-1)</sup> <br/>
                H<sub>2</sub><sup>(i)</sup> = c + H<sub>2</sub><sup>(i-1)</sup> <br/>
                H<sub>3</sub><sup>(i)</sup> = d + H<sub>3</sub><sup>(i-1)</sup> <br/>
                H<sub>4</sub><sup>(i)</sup> = e + H<sub>4</sub><sup>(i-1)</sup> <br/>
                H<sub>5</sub><sup>(i)</sup> = f + H<sub>5</sub><sup>(i-1)</sup> <br/>
                H<sub>6</sub><sup>(i)</sup> = g + H<sub>6</sub><sup>(i-1)</sup> <br/>
                H<sub>7</sub><sup>(i)</sup> = h + H<sub>7</sub><sup>(i-1)</sup> <br/>
            </p>
            <p>
                Теперь рассмотрим SHA-512. В данном случае инициализируются восемь
                64-битных переменных, которые будут являться промежуточным значением
                хэш-кода:
            </p>
            <p>
                a, b, c, d, e, f, g, h
            </p>
            <p>
                Основой алгоритма является модуль, состоящий из 80 циклических обработок
                каждого блока M<sup>(i)</sup>:
            </p>
            <p>
                T<sub>1</sub> = h + Σ<sub>1</sub><sup>{512}</sup>(e) + Ch(e, f, g) + K <sub>t</sub><sup>{512}</sup> +
                W<sub>t</sub>
            </p>
            <p>
                T<sub>2</sub> = Σ<sub>0</sub><sup>{512}</sup>(a) + Maj(a, b, c)
            </p>
            <p>
                h = g <br/>
                g = f <br/>
                f = e <br/>
                e = d + T<sub>1</sub> <br/>
                d = c <br/>
                c = b <br/>
                b = a <br/>
                a = T<sub>1</sub> + T<sub>2</sub> <br/>
            </p>
            <p>
                где K<sub>i</sub><sup>{512}</sup> - восемьдесят 64-битных констант, каждая
                из которых является первыми 64-мя битами дробной части кубических корней
                первых восьмидесяти простых чисел.
            </p>
            <p>
                W<sub>t</sub> вычисляются из очередного блока сообщения по следующим
                правилам:
            </p>
            <p>
                W<sub>t</sub> = M<sub>t</sub><sup>(i)</sup> , 0 ≤ t ≤ 15
            </p>
            <p>
                W<sub>t</sub> = σ<sub>1</sub><sup>{512}</sup>(W<sub>t-2</sub>) + W<sub>t-7</sub> + σ<sub>0</sub><sup>{512}</sup>(W<sub>t-15</sub>)
                + W <sub>t-16</sub> , 16 ≤ t ≤79
            </p>
            <p>
                i-ое промежуточное значение хэш-кода H(t) вычисляется следующим образом:
            </p>
            <p>
                H<sub>0</sub><sup>(i)</sup> = a + H<sub>0</sub><sup>(i-1)</sup> <br/>
                H<sub>1</sub><sup>(i)</sup> = b + H<sub>1</sub><sup>(i-1)</sup> <br/>
                H<sub>2</sub><sup>(i)</sup> = c + H<sub>2</sub><sup>(i-1)</sup> <br/>
                H<sub>3</sub><sup>(i)</sup> = d + H<sub>3</sub><sup>(i-1)</sup> <br/>
                H<sub>4</sub><sup>(i)</sup> = e + H<sub>4</sub><sup>(i-1)</sup> <br/>
                H<sub>5</sub><sup>(i)</sup> = f + H<sub>5</sub><sup>(i-1)</sup> <br/>
                H<sub>6</sub><sup>(i)</sup> = g + H<sub>6</sub><sup>(i-1)</sup> <br/>
                H<sub>7</sub><sup>(i)</sup> = h + H<sub>7</sub><sup>(i-1)</sup> <br/>
            </p>
            <p>
                Рассмотрим SHA-384. Отличия этого алгоритма от SHA-512:
            </p>
            <p>
                Другой начальный хэш-код H<sup>(0)</sup>.
            </p>
            <p>
                384-битный дайджест получается из левых 384 битов окончательного хэш-кода H <sup>(N)</sup>:
                H<sub>0</sub><sup>(N)</sup> || H<sub>1</sub><sup>(N)</sup>
                || H<sub>2</sub><sup>(N)</sup> || H<sub>3</sub><sup>(N)</sup> || H <sub>4</sub><sup>(N)</sup> ||
                H<sub>5</sub><sup>(N)</sup>.
            </p>

            <br/>
            <p>
                <strong style="font-size: 17px">6.9. Хэш-функция ГОСТ 3411-94</strong>
            </p>
            <p>
                Алгоритм <em>ГОСТ 3411</em> является отечественным стандартом для
                хэш-функций. Длина хэш-кода, создаваемого алгоритмом <em>ГОСТ 3411</em>,
                равна 256 битам. Алгоритм разбивает сообщение на блоки, длина которых также
                равна 256 битам. Кроме того, параметром алгоритма является стартовый вектор
                хэширования <em>Н</em> - произвольное фиксированное значение длиной также
                256 бит.
            </p>
            <p>
                <strong><em>Алгоритм обработки одного блока сообщения</em></strong>
            </p>
            <p>
                Сообщение обрабатывается блоками по 256 бит справа налево.
            </p>
            <p>
                Каждый блок сообщения обрабатывается по следующему алгоритму.
            </p>
            <ol>
                <li>
                    Генерация четырех ключей длиной 256 бит каждый.
                </li>
                <li>
                    Шифрование 64-битных значений промежуточного хэш-кода H на ключах K <sub>i</sub>(i = 1, 2, 3, 4) с
                    использованием алгоритма ГОСТ 28147 в режиме
                    простой замены.
                </li>
                <li>
                    Перемешивание результата шифрования.
                </li>
                <li>
                    Для генерации ключей используются следующие данные:

                    <ul type="disc">
                        <li>
                            промежуточное значение хэш-кода Н длиной 256 бит;
                        </li>
                        <li>
                            текущий обрабатываемый блок сообщения М длиной 256 бит;
                        </li>
                        <li>
                            параметры - три значения С<sub>2</sub>, С<sub>3</sub> и С<sub>4</sub>
                            длиной 256 бит следующего вида: С<sub>2</sub> и С<sub>4</sub> состоят
                            из одних нулей, а С<sub>3</sub> равно
                        </li>
                        <p>
                            1<sup>8</sup> 0<sup>8</sup> 1<sup>16</sup> 0<sup>24</sup> 1<sup>16</sup> 0<sup>8</sup>
                            (0<sup>8</sup>
                            1<sup>8</sup>)<sup>2</sup> 1<sup>8</sup> 0<sup>8</sup> (0<sup>8</sup>
                            1<sup>8</sup>)<sup>4</sup> (1<sup>8</sup>
                            0 <sup>8</sup>)<sup>4</sup>
                        </p>
                        <p>
                            где степень обозначает количество повторений 0 или 1.
                        </p>
                    </ul>
                </li>


            </ol>

            <p>
                Используются две формулы, определяющие перестановку и сдвиг.
            </p>
            <p>
                Перестановка Р битов определяется следующим образом: каждое 256-битное
                значение рассматривается как последовательность тридцати двух 8-битных
                значений.
            </p>
            <p>
                Перестановка Р элементов 256-битной последовательности выполняется по
                формуле y = φ(x), где x - порядковый номер 8-битного значения в исходной
                последовательности; y - порядковый номер 8-битного значения в
                результирующей последовательности.
            </p>
            <p>
                φ(i + 1 + 4(k - 1)) = 8i + k ; i = 0 ÷ 3, k = 1 ÷ 8
            </p>
            <p>
                Сдвиг А определяется по формуле
            </p>
            <p>
                A (x) = (x<sub>1</sub> ⊕
                x<sub>2</sub>) || x<sub>4</sub> || x<sub>3</sub> || x<sub>2</sub>
            </p>
            <p>
                Где
            <ul>
                <li>
                    x<sub>i</sub> - соответствующие 64 бита 256-битного
                    значения х,
                </li>
                <li>
                    || обозначает конкатенацию.
                </li>
            </ul>
            </p>

            <p>
                Присваиваются следующие начальные значения:
            </p>
            <p>
                i = 1, U = H, V = M.
            </p>
            <p>
                W = U ⊕
                V, K<sub>1</sub> = Р (W)
            </p>
            <p>
                Ключи K<sub>2</sub>, K<sub>3</sub>, K<sub>4</sub> вычисляются
                последовательно по следующему алгоритму:
            </p>
            <p>
                U = A(U) ⊕
                С<sub>i</sub>, V = A(A(V)), W = U ⊕
                V, K<sub>i</sub> = Р(W)
            </p>
            <p>
                Далее выполняется шифрование 64-битных элементов текущего значения хэш-кода
                Н с ключами K<sub>1</sub>, K<sub>2</sub>, K<sub>3</sub> и K<sub>4</sub>.
                При этом хэш-код Н рассматривается как последовательность 64-битных
                значений:
            </p>
            <p>
                H = h<sub>4</sub> || h<sub>3</sub> || h<sub>2</sub> || h<sub>1</sub>
            </p>
            <p>
                Выполняется шифрование алгоритмом ГОСТ 28147:
            </p>
            <p>
                s<sub>i</sub> = E<sub>Ki</sub> [h<sub>i</sub>] i = 1, 2, 3, 4
            </p>
            <p>
                S = s<sub>1</sub> || s<sub>2</sub> || s<sub>3</sub> || s<sub>4</sub>
            </p>
            <p>
                Наконец на заключительном этапе обработки очередного блока выполняется
                перемешивание полученной последовательности. 256-битное значение
                рассматривается как последовательность шестнадцати 16-битных значений.
                Сдвиг обозначается Ψ и определяется следующим образом:
            </p>
            <table border="0" cellspacing="1" cellpadding="0">
                <tbody>
                <tr>
                    <td valign="top">
                        <p>
                            η<sub>16</sub> || η<sub>15</sub> || ... || η<sub>1</sub> -
                            исходное значение
                        </p>
                    </td>
                </tr>
                <tr>
                    <td valign="top">
                        <p>
                            η<sub>1</sub> ⊕
                            η<sub>2</sub> ⊕
                            η<sub>3</sub> ⊕
                            η<sub>4</sub> ⊕
                            η<sub>13</sub> ⊕
                            η<sub>16</sub> || η<sub>16</sub> || ... || η<sub>2</sub> -
                            результирующее значение
                        </p>
                    </td>
                </tr>
                </tbody>
            </table>
            <p>
                Результирующее значение хэш-кода определяется следующим образом:
            </p>
            <p>
                Χ(M, H) = ψ<sup>61</sup> (H ⊕
                ψ (M ⊕
                ψ<sup> 12</sup>(S)))
            </p>
            <p>
                где

            <ul>
                <li>
                    H - предыдущее значение хэш-кода,
                </li>
                <li>
                    М - текущий обрабатываемый блок,
                </li>
                <li>
                    Ψ<sup>i</sup> - i-ая степень преобразования Ψ.
                </li>
            </ul>
            </p>
            <p>
                Входными параметрами алгоритма являются:
            </p>
            <ul type="disc">
                <li>
                    исходное сообщение М произвольной длины;
                </li>
                <li>
                    стартовый вектор хэширования Н, длина которого равна 256 битам;
                </li>
                <li>
                    контрольная сумма Σ, начальное значение которой равно нулю и длина
                    равна 256 битам;
                </li>
                <li>
                    переменная L, начальное значение которой равно длине сообщения.
                </li>
            </ul>
            <p>
                Сообщение М делится на блоки длиной 256 бит и обрабатывается справа налево.
                Очередной блок i обрабатывается следующим образом:
            </p>
            <ol>
                <li>
                    H = Χ(M<sub>i</sub>, H)
                </li>
                <li>
                    Σ = Σ ⊕
                    ' M<sub>i</sub>
                </li>
                <li>
                    L рассматривается как неотрицательное целое число, к этому числу
                    прибавляется 256 и вычисляется остаток от деления получившегося числа на 2 <sup>256</sup>. Результат
                    присваивается L.
                    <p>
                        Где ⊕
                        ' обозначает следующую операцию: Σ и M<sub>i</sub> рассматриваются как
                        неотрицательные целые числа длиной 256 бит. Выполняется обычное сложение
                        этих чисел и находится остаток от деления результата сложения на 2 <sup>256</sup>. Этот остаток
                        и
                        является результатом операции.
                    </p>
                </li>

            </ol>

            <p>
                Самый левый, т.е. самый последний блок М' обрабатывается так:

            <ol>
                <li>
                    Блок добавляется слева нулями так, чтобы его длина стала равна 256
                    битам.
                </li>
                <li>
                    Вычисляется Σ = Σ ⊕
                    ' M<sub>i</sub>.
                </li>
                <li>
                    L рассматривается как неотрицательное целое число, к этому числу
                    прибавляется длина исходного сообщения М и находится остаток от деления
                    результата сложения на 2<sup>256</sup>.
                </li>
                <li>
                    Вычисляется Н = Χ(М', Н).
                </li>
                <li>
                    Вычисляется Н = Χ(L, Н).
                </li>
                <li>
                    Вычисляется Н = Χ(Σ, Н).
                </li>
            </ol>
            </p>

            <p>
                Значением функции хэширования является Н.
            </p>
            <a href="../lk10/lk10.html">Следующая лекция - Коды аутентификации сообщений - МАС
            </a>
        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
