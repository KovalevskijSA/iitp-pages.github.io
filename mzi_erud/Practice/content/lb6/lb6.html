<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top;
        /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%;
        /* Ширина первой колонки */
    }

    #col2 {
        width: 80%;
        /* Ширина второй колонки */
    }

    #col3 {
        width: 10%;
        /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>Лабораторная работа №6</strong>
            </h3>
            <p align="center">
                <strong style="font-size: 18px">Компьютерная реализация электронной цифровой подписи.</strong>
            </p>
            <p style="font-style: italic">Реализовать программные средства формирования электронной цифровой подписи
                на примере алгоритма ГОСТ 3410.
            </p>
            <p>
                <strong style="font-size: 18px">
                    ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                </strong>
            </p>
            <ol>
                <li>
                    <p><strong>
                        Отечественный стандарт цифровой подписи ГОСТ 3410</strong>
                    </p>
                    <p>
                        В стандарте <em>ГОСТ 3410</em> используется хэш-функция ГОСТ 3411, которая
                        создает хэш-код длиной 256 бит. Это во многом обуславливает требования к
                        выбираемым простым числам p и q: р должно быть простым числом в диапазоне
                        2<sup>509</sup> &lt; p &lt; 2<sup>512 </sup>либо 2<sup>1020</sup> &lt; p; q должно быть простым
                        числом в диапазоне 2<sup>254</sup> &lt; q &lt; 2 <sup>256</sup>
                        , q также должно быть делителем (р-1).
                    </p>
                    <p>
                        Аналогично выбирается и параметр g.
                    </p>
                    <p>
                        При этом требуется, чтобы g<sup>q</sup> (mod p) = 1.
                    </p>
                    <p>
                        В соответствии с <strong>теоремой Ферма</strong> это эквивалентно условию в <em>DSS</em>, что g
                        = h<sup>(p-1)/q</sup> mod p.
                    </p>
                    <p>
                        Закрытым ключом является произвольное число х: 0 &lt; x &lt; q
                    </p>
                    <p>
                        Открытым ключом является число y: y = g<sup>x</sup> mod p
                    </p>
                    <p>
                        Для создания подписи выбирается случайное число k: 0 &lt; k &lt; q
                    </p>
                    <p>
                        Подпись состоит из двух чисел (r, s), вычисляемых по следующим формулам:
                    </p>
                    <p>
                        r = (g<sup>k</sup> mod p) mod q
                    </p>
                    <p>
                        s = (k H(M) + xr) mod q
                    </p>
                    <p>
                        Обратим внимание на отличия <em>DSS</em> и <em>ГОСТ 3410</em>.
                    </p>
                    <ol>
                        <li>
                            Используются разные хэш-функции: в <em>ГОСТ 3410</em> применяется
                            отечественный стандарт на хэш-функции ГОСТ 3411, в <em>DSS</em>
                            используется SHA-1, которые имеют разную длину хэш-кода. Отсюда и разные
                            требования на длину простого числа q: в <em>ГОСТ 3410</em> длина q должна
                            быть от 254 бит до 256 бит, а в <em>DSS</em> длина q должна быть от 159 бит
                            до 160 бит.
                        </li>
                        <li>
                            По-разному вычисляется компонента s подписи.

                            <p>
                                В <em>ГОСТ 3410</em> компонента s вычисляется по формуле: s = (k H(M) + xr) mod q
                            </p>
                            <p>
                                В <em>DSS</em> компонента s вычисляется по формуле: s = [k<sup>-1</sup> (H(M) + xr)] mod
                                q
                            </p>
                        </li>
                    </ol>

                    <p>
                        Последнее отличие приводит к соответствующим отличиям в формулах для
                        проверки подписи.
                    </p>
                    <p>
                        Получатель вычисляет w = H(M)<sup>-1</sup> mod q
                    </p>
                    <p>
                        u<sub>1</sub> = w s mod q
                    </p>
                    <p>
                        u<sub>2</sub> = (q-r) w mod q
                    </p>
                    <p>
                        v = [(g<sup>u1</sup> y<sup>u2</sup>) mod p] mod q
                    </p>
                    <p>
                        Подпись корректна, если v = r.
                    </p>
                    <p>
                        Структура обоих алгоритмов довольно интересна. Заметим, что значение r
                        совсем не зависит от сообщения. Вместо этого r есть функция от k и трех
                        общих компонент открытого ключа. Мультипликативная инверсия k (mod p) (в
                        случае <em>DSS</em>) или само значение k (в случае ГОСТ 3410) подается в
                        функцию, которая, кроме того, в качестве входа имеет хэш-код сообщения и
                        закрытый ключ пользователя. Эта функция такова, что получатель может
                        вычислить r, используя входное сообщение, подпись, открытый ключ
                        пользователя и общий открытый ключ.
                    </p>
                    <p>
                        В силу сложности вычисления дискретных логарифмов нарушитель не может
                        восстановить k из r или х из s.
                    </p>
                    <p>
                        Другое важное замечание заключается в том, что экспоненциальные вычисления
                        при создании подписи необходимы только для g<sup>k</sup> mod p. Так как это
                        значение от подписываемого сообщения не зависит, оно может быть вычислено
                        заранее. Пользователь может заранее просчитать некоторое количество
                        значений r и использовать их по мере необходимости для подписи документов.
                        Еще одна задача состоит в определении мультипликативной инверсии k <sup>-1</sup> (в случае <em>DSS</em>).
                        Эти значения также могут быть
                        вычислены заранее.
                    </p>
                </li>


                <li>
                    <p><strong>
                        Хэш-функция ГОСТ 3411-94
                    </strong></p>
                    <p>
                        Алгоритм <em>ГОСТ 3411</em> является отечественным стандартом для
                        хэш-функций. Длина хэш-кода, создаваемого алгоритмом <em>ГОСТ 3411</em>,
                        равна 256 битам. Алгоритм разбивает сообщение на блоки, длина которых также
                        равна 256 битам. Кроме того, параметром алгоритма является стартовый вектор
                        хэширования <em>Н</em> - произвольное фиксированное значение длиной также
                        256 бит.
                    </p>
                    <p>
                        <strong><em>Алгоритм обработки одного блока сообщения</em></strong>
                    </p>
                    <p>
                        Сообщение обрабатывается блоками по 256 бит справа налево.
                    </p>
                    <p>
                        Каждый блок сообщения обрабатывается по следующему алгоритму.
                    </p>
                    <ol>
                        <li>
                            Генерация четырех ключей длиной 256 бит каждый.
                        </li>
                        <li>
                            Шифрование 64-битных значений промежуточного хэш-кода H на ключах K <sub>i</sub>(i = 1, 2,
                            3, 4) с использованием алгоритма ГОСТ 28147 в режиме
                            простой замены.
                        </li>
                        <li>
                            Перемешивание результата шифрования.
                        </li>
                    </ol>
                    <p>
                        Для генерации ключей используются следующие данные:
                    </p>
                    <ul>
                        <li>
                            промежуточное значение хэш-кода Н длиной 256 бит;
                        </li>
                        <li>
                            текущий обрабатываемый блок сообщения М длиной 256 бит;
                        </li>
                        <li>
                            параметры - три значения С<sub>2</sub>, С<sub>3</sub> и С<sub>4</sub>
                            длиной 256 бит следующего вида: С<sub>2</sub> и С<sub>4</sub> состоят
                            из одних нулей, а С<sub>3</sub> равно <br/>
                            1<sup>8</sup> 0<sup>8</sup> 1<sup>16</sup> 0<sup>24</sup> 1<sup>16</sup> 0<sup>8</sup>
                            (0<sup>8</sup> 1<sup>8</sup>)<sup>2</sup> 1<sup>8</sup> 0<sup>8</sup> (0<sup>8</sup>
                            1<sup>8</sup>)<sup>4</sup> (1<sup>8</sup> 0 <sup>8</sup>)<sup>4</sup> ,
                            где степень обозначает количество повторений 0 или 1.
                        </li>
                    </ul>
                    <p>

                    </p>
                    <p>

                    </p>
                    <p>
                        Используются две формулы, определяющие <strong>перестановку</strong> и <strong>сдвиг</strong>.
                    </p>
                    <p>
                        <strong>Перестановка Р битов</strong> определяется следующим образом: каждое 256-битное
                        значение рассматривается как последовательность тридцати двух 8-битных
                        значений.
                    </p>
                    <p>
                        <strong>Перестановка Р элементов</strong> 256-битной последовательности выполняется по
                        формуле y = φ(x), где x - порядковый номер 8-битного значения в исходной
                        последовательности; y - порядковый номер 8-битного значения в
                        результирующей последовательности.
                    </p>
                    <p>
                        φ(i + 1 + 4(k - 1)) = 8i + k ; i = 0 ÷ 3, k = 1 ÷ 8
                    </p>
                    <p>
                        Сдвиг А определяется по формуле
                    </p>
                    <p>
                        A (x) = (x<sub>1</sub> ⊕
                        x<sub>2</sub>) || x<sub>4</sub> || x<sub>3</sub> || x<sub>2</sub>
                    </p>
                    <p>
                        Где x<sub>i</sub> - соответствующие 64 бита 256-битного
                        значения х, || обозначает конкатенацию.
                    </p>
                    <p>
                        Присваиваются следующие начальные значения:
                    </p>
                    <p>
                        i = 1, U = H, V = M.
                    </p>
                    <p>
                        W = U ⊕
                        V, K<sub>1</sub> = Р (W)
                    </p>
                    <p>
                        Ключи K<sub>2</sub>, K<sub>3</sub>, K<sub>4</sub> вычисляются
                        последовательно по следующему алгоритму:
                    </p>
                    <p>
                        U = A(U) ⊕
                        С<sub>i</sub>, V = A(A(V)), W = U ⊕
                        V, K<sub>i</sub> = Р(W)
                    </p>
                    <p>
                        Далее выполняется шифрование 64-битных элементов текущего значения хэш-кода
                        Н с ключами K<sub>1</sub>, K<sub>2</sub>, K<sub>3</sub> и K<sub>4</sub>.
                        При этом хэш-код Н рассматривается как последовательность 64-битных
                        значений:
                    </p>
                    <p>
                        H = h<sub>4</sub> || h<sub>3</sub> || h<sub>2</sub> || h<sub>1</sub>
                    </p>
                    <p>
                        Выполняется шифрование алгоритмом ГОСТ 28147:
                    </p>
                    <p>
                        s<sub>i</sub> = E<sub>Ki</sub> [h<sub>i</sub>] i = 1, 2, 3, 4
                    </p>
                    <p>
                        S = s<sub>1</sub> || s<sub>2</sub> || s<sub>3</sub> || s<sub>4</sub>
                    </p>
                    <p>
                        Наконец на заключительном этапе обработки очередного блока выполняется
                        перемешивание полученной последовательности. 256-битное значение
                        рассматривается как последовательность шестнадцати 16-битных значений.
                        Сдвиг обозначается Ψ и определяется следующим образом:
                    </p>
                    <table border="0" cellspacing="1" cellpadding="0">
                        <tbody>
                        <tr>
                            <td valign="top">
                                <p>
                                    η<sub>16</sub> || η<sub>15</sub> || ... || η<sub>1</sub> -
                                    исходное значение
                                </p>
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">
                                <p>
                                    η<sub>1</sub> ⊕
                                    η<sub>2</sub> ⊕
                                    η<sub>3</sub> ⊕
                                    η<sub>4</sub> ⊕
                                    η<sub>13</sub> ⊕
                                    η<sub>16</sub> || η<sub>16</sub> || ... || η<sub>2</sub> -
                                    результирующее значение
                                </p>
                            </td>
                        </tr>
                        </tbody>
                    </table>
                    <p>
                        Результирующее значение хэш-кода определяется следующим образом:
                    </p>
                    <p>
                        Χ(M, H) = ψ<sup>61</sup> (H ⊕
                        ψ (M ⊕
                        ψ<sup> 12</sup>(S)))
                    </p>
                    <p>
                        где H - предыдущее значение хэш-кода, М - текущий обрабатываемый блок, Ψ<sup>i</sup> - i-ая
                        степень преобразования Ψ.
                    </p>

                    <p>
                        Входными параметрами алгоритма являются:
                    </p>
                    <ul>
                        <li>
                            исходное сообщение М произвольной длины;
                        </li>
                        <li>
                            стартовый вектор хэширования Н, длина которого равна 256 битам;
                        </li>
                        <li>
                            контрольная сумма Σ, начальное значение которой равно нулю и длина равна
                            256 битам;
                        </li>
                        <li>
                            переменная L, начальное значение которой равно длине сообщения.
                        </li>
                    </ul>

                    <p>
                        Сообщение М делится на блоки длиной 256 бит и обрабатывается справа налево.
                        Очередной блок i обрабатывается следующим образом:
                    </p>
                    <ol>
                        <li>
                            H = Χ(M<sub>i</sub>, H)
                        </li>
                        <li>
                            Σ = Σ⊕' M<sub>i</sub>
                        </li>
                        <li>
                            L рассматривается как неотрицательное целое число, к этому числу
                            прибавляется 256 и вычисляется остаток от деления получившегося числа на 2 <sup>256</sup>.
                            Результат присваивается L. <br/>
                            Где ⊕ обозначает следующую операцию: Σ и M<sub>i</sub> рассматриваются как
                            неотрицательные целые числа длиной 256 бит. Выполняется обычное сложение
                            этих чисел и находится остаток от деления результата сложения на 2 <sup>256</sup>. Этот
                            остаток и является результатом операции.
                        </li>
                    </ol>
                    <p>
                        Самый левый, т.е. самый последний блок М' обрабатывается так:
                    </p>
                    <ol>
                        <li>
                            Блок добавляется слева нулями так, чтобы его длина стала равна 256
                            битам.
                        </li>
                        <li>
                            Вычисляется Σ = Σ⊕' M<sub>i</sub>.
                        </li>
                        <li>
                            L рассматривается как неотрицательное целое число, к этому числу
                            прибавляется длина исходного сообщения М и находится остаток от деления
                            результата сложения на 2<sup>256</sup>.
                        </li>
                        <li>
                            Вычисляется Н = Χ(М', Н).
                        </li>
                        <li>
                            Вычисляется Н = Χ(L, Н).
                        </li>
                        <li>
                            Вычисляется Н = Χ(Σ, Н).
                        </li>
                    </ol>
                    <p>
                        Значением функции хэширования является Н.
                    </p>
                </li>
            </ol>


            <br clear="all"/>
            <p>
                <strong style="font-size: 18px">
                    ЗАДАНИЕ:
                </strong>

                <ol>
                    <li>
                        Изучить теоретические сведения.
                    </li>
                    <li>
            <p>Создать программы, читающие данные из файла и формирующие в качестве
                выхода <em>дайджест сообщения</em> длиной 128 бит по алгоритму MD5 на языке
                программирования С++.</p>
            </li>
            <li>
                По результатам каждой работы студентом должен быть представлен и
                защищен отчет. <br>
                <p>
                    <strong>Содержание отчета включает:</strong>
                <ol>
                    <li>
                        Титульный лист
                    </li>
                    <li>
                        Постановку задачи и описание использованных алгоритмов.
                    </li>
                    <li>
                        Блок – схему алгоритма.
                    </li>
                    <li>
                        Распечатку скриншотов результатов ввода данных и исполнения программы.
                    </li>
                    <li>
                        Распечатку программного кода.
                    </li>
                    <li>
                        Вывод.
                    </li>
                </ol>

        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>

