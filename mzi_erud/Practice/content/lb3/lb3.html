<!DOCTYPE>
<HTML lang="ru">
<HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <title></title>
</HEAD>
<body>
<style type="text/css">
    TD {
        vertical-align: top;
        /* Выравнивание по верхнему краю ячейки */
    }

    #col1 {
        width: 10%;
        /* Ширина первой колонки */
    }

    #col2 {
        width: 80%;
        /* Ширина второй колонки */
    }

    #col3 {
        width: 10%;
        /* Ширина третьей колонки */
    }
</style>

<table>
    <tr>
        <td id="col1"></td>
        <td id="col2">
            <h3 align="center">
                <strong>Лабораторная работа №3</strong>
            </h3>
            <p align="center">
                <strong style="font-size: 18px">Компьютерная реализация стандарта AES.</strong>
            </p>
            <p style="font-style: italic">Реализовать программные средства шифрования и дешифрования текстовых файлов
                при помощи стандарта AES
            </p>
            <p>
                <strong style="font-size: 18px">
                    ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
                </strong>
            </p>
<p>
    <strong>AES</strong> – симметричный итеративный блоковый алгоритм;
</p>
<p>
    AES – не шифр Фейстеля, базируется на принципах новой сети
    подстановок-перестановок.
</p>
<p>
    Имеет новую архитектуру SQUARE (КВАДРАТ), для которой характерно:

    <ol>
            <li>
                представление шифруемого блока в виде двумерного байтового массива;
            </li>
            <li>
                шифрование за один раунд всего блока данных (    <em>байт-ориентированная структура</em>);
            </li>
            <li>
                выполнение криптографических преобразований, как над отдельными байтами
                массива, так и над его строками и столбцами.
            </li>
        </ol>
</p>

<p>
    AES зашифровывает и расшифровывает 128-битовые блоки данных.
</p>
<p>
    AES позволяет использовать три различных ключа длиной 128,192 или 256 бит
    (в зависимости от длины ключа версии шифра обозначают AES-128, AES-192 или
    AES-256).
</p>
<p>
    От размера ключа зависит число раундов шифрования:

    <ul>
            <li>
                длина 128 бит – 10 раундов;
            </li>
            <li>
                длина 192 бита – 12 раундов;
            </li>
            <li>
                длина 256 бит – 14 раундов.
            </li>
            <li>
                Все раунды, кроме последнего, идентичны.
            </li>
        </ul>
        </p>
<p>
    Основным элементом, которым оперирует алгоритм AES, является байт.
</p>
<p>
    Для формирования байтов 128 битов блока открытого текста, выходного блока
    шифротекста и ключа шифра делятся на группы из 8-ми рядом стоящих бит так,
    чтобы в целом получился массив байт.
</p>

<p align="center">
        <img
            width="624"
            height="140"
            src="../../images/lb3/1.png"
        />
    <p align="center">
            Рисунок 1. Принятая нумерация бит в пределах каждого байта
        </p>
</p>
            <ol>
                <li>
                    <p><strong>Приедставление данных в криптоалгоритма AES</strong></p>

                    <p>
                        Задавать значение байта удобно в шестнадцатеричной системе исчисления.
                    </p>
                    <p>
                        Для этого байт делится на две группы из 4-х бит: группа старших бит в байте
                        представляется первым шестнадцатеричным символом, а группа младших бит –
                        вторым.
                    </p>
                    <p>
                        Например, для байта 10101100 получим
                    </p>
                    <p>
                        10101100 = 1010 1100 = АС.
                    </p>
                    <p>
                        Обозначим:
                    </p>
                    <p>
                        in0, in1,…, in15 – 16 байт блока открытого текста;
                    </p>
                    <p>
                        k0, k1,…, k15 – 16 байт ключа шифра;
                    </p>
                    <p>
                        <em>о</em>
                        <em>ut</em>
                        0, <em>out</em>1,…, <em>out</em>15 – 16 байт блока шифротекста.
                    </p>
                    <p>
                        Внутри алгоритма операции выполняются над матрицей байт, называемой    <em>матрицей состояний State </em>или просто <em>состоянием</em>.
                    </p>
                    <p align="center">
                            <img
                                    width="60%"
                                    height="80%"
                                    src="../../images/lb3/2.jpg"
                            />
                    </p>
                    <p>
                        Четыре байта в каждом столбце матрицы состояний или ключа можно
                        рассматривать как одно 32-х битовое <strong><em>слово</em></strong>.
                    </p>
                    <p>
                        Поэтому матрица состояний – это массив из 4 слов <em>w</em>0,<em>w</em>1,    <em>w</em>2,<em>w</em>3, где
                    </p>
                    <p align="center">
                        <img
                                width="272"
                                height="179"
                                src="../../images/lb3/3.png"
                        />
                    </p>
                    <p>
                        Матрица, поступающая на вход каждого раунда называется матрицей Inpu    <em>tState</em>, а на выходе раунда образуется матрица Outpu<em>tState</em>
                        .
                    </p>
                    <p>
                        Очевидно, на входе первого раунда Inpu<em>tState=</em>Input<em>Block</em>,
                        а на выходе последнего раунда Outpu<em>tState= </em>Outpu<em>tBlock</em>.
                    </p>
                    <p>
                        Например, представим в виде матрицы Inpu<em>tBlock </em>текст
                    </p>
                    <p>
                        СКЛАДНІСТЬЗАДАЧІ = (21 14 15 00 05 17 11 21 22 30 09 00 05 00 27 11)10= (15
                        0Е 0F 00 05 11 0B 15 16 1E 09 00 05 00 1B 0B )16
                    </p>
                    <p align="center">
                        <img
                                width="282"
                                height="86"
                                src="../../images/lb3/31.jpg"
                        />
                    </p>
                    <p>
                        В рассматриваемой версии алгоритма AES-128 ключ шифра состоит из 128 битов,
                        поделенных на 16 байтов k0,k1,...,k15 , и записывается в столбцы матрицы
                        InputKey.
                    </p>
                    <p>
                        Каждый столбец матрицы InputKey образует слово, т.е. фактически ключ шифра
                        – это четыре слова w0,w1,w2,w3, где w0 = k0k1k2k3, w1 = k4k5k6k7 и т.д.
                    </p>
                    <p align="center">
                        <img
                                width="365"
                                height="230"
                                src="../../images/lb3/4.png"
                        />
                    </p>
                    <p>
                        Они играют роль раундового ключа.
                    </p>
                    <p>
                        Из этих слов с помощью специального алгоритма образуется последовательность
                        из 44 слов: w0,w1,w2,...,w43 (каждое слово по 32 бита).
                    </p>
                    <p>
                        На каждый раунд шифрования подаются по четыре слова этой
                        последовательности.
                    </p>
                    <ul type="disc">
                        <li >
                            <p><strong>Схема преобразования данных</strong></p>
                            <p align="center">
                                <img
                                        width="565"
                                        height="430"
                                        src="../../images/lb3/5.png"
                                />
                            </p>
                            <p align="center" style="margin-left: 90px">
                                Рисунок 2. Схема преобразования данных
                            </p>
                        </li>
                        <li>
                            <p><strong>Структура раунда AES</strong></p>
                            <p>
                                Перед первым раундом выполняется операция    <strong>AddRound<em>Key</em></strong><em> </em>(суммирование по модулю 2 с
                                начальным ключом шифра). Преобразования, выполненные в одном раунде,
                                обозначают <strong>Round (</strong><strong><em>State</em>, </strong><strong><em>RoundKey</em>),</strong>где <strong><em>State</em></strong>    <em> </em>– матрица, описывающая данные на входе раунда и на его выходе
                                после шифрования; <strong><em>RoundKey</em></strong><em> </em>– матрица,
                                содержащая раундовый ключ.
                            </p>
                            <p align="center">
                                <img
                                        width="526"
                                        height="386"
                                        src="../../images/lb3/61.png"
                                />
                            </p>

                            <p>
                                Раунд состоит из 4 различных преобразований:
                            </p>
                            <p>
                                <strong>SubBytes </strong>
                                – побайтовая подстановка в S-боксе с фиксированной таблицей замен;
                            </p>
                            <p>
                                <strong>ShiftRows </strong>
                                – побайтовый сдвиг строк матрицы State на различное количество байт;
                            </p>
                            <p>
                                <strong>MixColumns</strong>
                                – перемешивание байт в столбцах;
                            </p>
                            <p>
                                <strong>AddRoundKey </strong>
                                – сложение с раундовым ключом (операция XOR).
                            </p>
                            <p>
                                Последний раунд несколько отличается от предыдущих тем, что не задействует
                                функцию <strong>MixColumns</strong>.
                            </p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p>Раундовое преобразование AES</p>
                    <ul type="disc">
                        <li>
                            <p>
                                <strong>Операция SubBytes.</strong>
                            </p>
                            <p>
                                Операция выполняет нелинейную замену байтов, выполняемую независимо с
                                каждым байтом матрицы <em>State</em>.
                            </p>
                            <p>
                                Замена обратима и построена путем комбинации двух преобразований над
                                входным байтом:
                            </p>
                            <p>
                                нахождение обратного (инвертированного) элемента относительно умножения в
                                поле GF (2<sup>3</sup>)
                                (считается, что нулевой байт {00} переходит сам в себя);
                            </p>
                            <p>
                                выполнение некого аффинного преобразования:
                            </p>
                            <p>
                                умножение инвертированного байта на многочлен
                            </p>
                            <p align="center">
                                <img
                                        width="234"
                                        height="26"
                                        src="../../images/lb3/71.png"
                                />
                                и суммирование с многочленом
                            </p>
                            <p>
                                <img
                                        width="191"
                                        height="26"
                                        src="../../images/lb3/8.png"
                                />
                                в поле <em>F</em>2[<em>x</em>] / <em>x  + </em>1.
                            </p>
                            <p>
                                Заметим, что
                                <img
                                        width="177"
                                        height="26"
                                        src="../../images/lb3/9.png"
                                />
                                и
                                <img
                                        width="172"
                                        height="26"
                                        src="../../images/lb3/101.png"
                                />
                            </p>
                            <p>
                                В матричной форме процедура SubBytes записывается как
                            </p>
                            <p align="center">
                                <img
                                        width="454"
                                        height="266"
                                        src="../../images/lb3/10.png"
                                />
                            </p>
                            <p>
                                Где <em>x - </em>входные биты, <em>y </em>– выходные.
                            </p>
                            <p>
                                Если на вход функции попадает нулевой байт, то результатом замены будет
                                число <em>y = b</em>.
                                <br clear="all"/>
                            </p>
                            <p>
                                Процесс замены байтов с помощью таблицы подстановки иллюстрирует рисунок.
                            </p>
                            <p align="center">
                                <img
                                        width="536"
                                        height="263"
                                        src="../../images/lb3/11.png"
                                />
                            </p>
                            <p>
                                Нелинейность преобразования обусловлена нелинейностью инверсии x<sup>-1</sup>, а обратимость – обратимостью матрицы.
                            </p>
                            <p>
                                Созданную на основе этой операции специальную таблицу замен байтов в
                                шестнадцатеричной системе называют <strong><em>S</em>-боксом</strong>.
                            </p>
                            <p>
                                Например, если <em>s</em>1,1 = {8<em>A</em>}, то результат замены этого
                                байта следует искать на пересечении строки с индексом 8 и столбца с
                                индексом <em>A</em>, т.е. SubBytes(8<em>A</em>)={7<em>E</em>}.
                            </p>
                            <p align="center">
                                <img
                                        width="630"
                                        height="337"
                                        src="../../images/lb3/12.png"
                                />
                            </p>
                            <p align="center">
                                Рисунок 3. Раундовое преобразование SubBytes
                            </p>
                        </li>
                        <li>
                            <p>
                                <strong>Операция ShiftRows.</strong>
                            </p>
                            <p>
                                Операция применяется к строкам матрицы <em>State </em>– ее первая строка
                                неподвижна, а элементы нижних трех строк циклически сдвигаются вправо на 1,
                                2 и 3 байта соответственно.
                            </p>
                            <p align="center">
                                <img
                                        src="../../images/lb3/13.jpg"
                                />
                            </p>
                            <p>
                                По сути это перестановка элементов матрицы, в которой участвуют только
                                элементы строк, поэтому преобразование обратимо.
                            </p>
                            <p align="center">
                                <strong>
                                    <img
                                            width="619"
                                            height="246"
                                            src="../../images/lb3/14.png"
                                    />
                                </strong>
                                <strong></strong>
                            </p>
                        </li>
                        <li>
                            <p>
                                <strong>Операция MixColumns.</strong>
                            </p>
                            <p>
                                С помощью этой операции выполняется перемешивание байтов в столбцах матрицы    <em>State</em>.
                            </p>
                            <p>
                                Каждый столбец этой матрицы принимается за многочлен над полем GF (2<sup>3</sup>)
                                и умножается на фиксированный многочлен
                            </p>
                            <p>
                                <img
                                        width="539"
                                        height="26"
                                        src="../../images/lb3/16.png"
                                />
                            </p>
                            <p>
                                по модулю многочлена x<sup>4</sup>  +  1 (напомним, все коэффициенты многочленов над полем <em>GF</em>(28)– байты).
                            </p>
                            <p>
                                Как показано выше, такую операцию можно записать в матричном виде как
                            </p>
                            <p align="center">
                                <img
                                        width="430"
                                        height="140"
                                        src="../../images/lb3/17.jpg"
                                />
                            </p>
                            <p>
                                Многочлен <em>c</em>(<em>x</em>) – взаимно простой с многочленом x<sup>4</sup>  +  1
                                над полем GF (2<sup>3</sup>)
                                , поэтому в поле существует обратный многочлен c<sup>-1</sup>(x) (mod x<sup>4</sup>  +  1) матрица в этой формуле обратима.
                            </p>
                            <p align="center">
                                <strong>
                                    <img
                                            width="592"
                                            height="318"
                                            src="../../images/lb3/18.png"
                                    />
                                </strong>
                            </p>
                        </li>
                        <li>
                            <p>
                                <strong>Операция AddRoundKey.</strong>
                            </p>
                            <p>
                                <img
                                        width="354"
                                        height="273"
                                        src="../../images/lb3/19.png"
                                        align="left"
                                        hspace="12"
                                />
                                <em>Функция</em>
                                <em> </em>
                                AddRoundKey(<em>State</em>, <em>RoundKey</em>) побитово складывает элементы
                                переменной <em>RoundKey </em>и элементы переменной <em>State </em>по
                                принципу: <em>i</em>-й столбец данных (<em>i=</em>0,1,2,3) складывается с
                                определенным 4-байтовым фрагментом расширенного ключа <em>W </em>[4    <em>r + </em>1], где <em>r </em>– номер поточного раунда алгоритма.
                            </p>
                            <p>
                                При шифровании первое сложение ключа раунда происходит до первого
                                выполнения операции SubBytes.
                            </p>
                            <strong>
                                <br clear="all"/>
                            </strong>
                            <p>
                                <strong></strong>
                            </p>
                            <p align="center">
                                <strong>
                                    <img
                                            width="301"
                                            height="319"
                                            src="../../images/lb3/20.png"
                                    />
                                </strong>
                            </p>
                            <p>
                                Рисунок демонстрирует свойства рассеивания и перемешивания информации в
                                ходе шифрование алгоритмом AES. Видно, что два раунда обеспечивают полное
                                рассеивание и перемешивание информации. Достигается это за счет
                                использования функций ShiftRows и MixColumns. Операция SubBytes придает
                                шифрованию стойкость против дифференциального криптоанализа, а операция
                                AddRoundKey обеспечивает необходимую секретную случайность.
                            </p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p>
                        <strong>Ключевое расписание AES</strong>
                    </p>
                    <p>
                        Раундовые ключи вырабатываются из ключа шифра <em>K </em>с помощью
                        процедуры <em>расширения ключа</em>, в результате чего формируется массив
                        раундовых ключей, из которого затем непосредственно выбирается необходимый
                        раундовый ключ.
                    </p>
                    <p>
                        Каждый раундовый ключ имеет длину 128 бит (или 4 четырехбайтовых слова    <em>wi </em>,<em>wi + </em>1,<em>wi + </em>2,<em>wi + </em>3, а длина в битах
                        всех раундовых ключей равна:
                    </p>
                    <p>
                        128 бит*(10 раундов + 1) = 1408 бит (или 44 четырехбайтовых слова <em>w</em>
                        0,<em>w</em>1,<em>w</em>2,...,<em>w</em>42,<em>w</em>43 ).
                    </p>
                    <p>
                        Первые четыре слова <em>w</em>0,<em>w</em>1,<em>w</em>2,<em>w</em>3 в
                        ключевом массиве заполнены ключом шифра, из остальных выработанных 40 слов
                        выбираются по 4 слова для ключа раунда.
                    </p>
                    <p>
                        Выбор слов прост: первые четыре слова (они совпадают с ключом шифра)
                        являются ключом с номером 0, следующие четыре слова <em>w</em>4,<em>w</em>
                        5,<em>w</em>6,<em>w</em>7 – раундовым ключом для первого полного раунда и
                        т.д.
                    </p>
                    <p>
                        Новые слова <em>wi + </em>4,<em>wi + </em>5,<em>wi + </em>6,<em>wi + </em>7
                        следующего раундового ключа определяются из слов <em>wi</em>,<em>wi + </em>1,    <em>wi + </em>2,<em>wi + </em>3 предыдущего ключа на основе уравнений:
                    </p>
                    <p>
                        Wi + 5 = Wi + 4 ⊕ Wi + 1;
                    </p>
                    <p>
                        Wi + 6 = Wi + 5 ⊕ Wi + 2;
                    </p>
                    <p>
                        Wi + 7 = Wi + 6 ⊕ Wi + 3.
                    </p>
                    <p>
                        Первое слово <em>Wi</em> + 4 в каждом раундовом ключе изменяется подругому:
                    </p>
                    <p>
                        <em>Wi + </em>
                        4 = <em>Wi </em> ⊕ <em>g</em>(<em>Wi + </em>3),
                    </p>
                    <p>
                        Здесь действие функции <em>g </em>сводится к последовательному выполнению
                        трех шагов, отображающих слово в слово:
                    </p>
                    <ol>
                        <li>
                            циклический сдвиг четырехбайтового слова влево на один байт (операция
                            RotWord);
                        </li>
                        <li>
                            замена каждого байта слова, полученного на шаге 1, в соответствии с
                            таблицей SubBytes, используемой при шифровании (операция SubWord);
                        </li>
                        <li>
                            суммирование по mod2 байтов, полученных на шаге 2, с раундовой
                            постоянной Rcon[i] = (RC[i],0,0,0), несекретной и уникальной для каждого
                            раундового ключа <em>Ki </em>.
                        </li>
                    </ol>
                    <p>
                        Три самые правые байты этой константы – нулевые, а ненулевой левый байт
                        меняется по известному закону рекурсии:
                    </p>
                    <p>
                        RC[1] =1, RC[i] = 2 * RC[i -1], i =1,2,...10 .
                    </p>
                    <p>
                        Цель суммирования с раундовыми константами – разрушить любую симметрию, что
                        может возникнуть на разных этапах разворачивания ключа и привести к
                        появлению слабых ключей, как в алгоритме DES.
                    </p>
                    <p>
                        Работа алгоритма расширения ключа продемонстрирована на рис. 4
                    </p>
                    <p align="center">
                        <img
                                width="444"
                                height="211"
                                src="../../images/lb3/21.png"
                        />

                    </p>
                    <p align="center">
                        Рисунок 4. Работа алгоритма расширения ключа
                    </p>
                    <ul>
                        <li>
                            <p>
                                <strong>ПРИМЕР. </strong> <br/>
                                Начало зашифрования
                            </p>
                            <p>
                                Ключ шифра OF <strong>15 71 </strong><strong>C9 47 </strong><strong>D9 </strong><strong>E8 59 0</strong><strong>C </strong><strong>B7 </strong><strong>AD </strong><strong>DF </strong>    <strong>AF 7</strong><strong>F 67 98</strong>
                            </p>
                            <p align="center">
                                <img
                                        width="630"
                                        height="394"
                                        src="../../images/lb3/22.png"
                                />
                            </p>
                        </li>
                    </ul>

                </li>
            <li>
                <p>
                    <strong>Расшифрование AES</strong>
                </p>
                <p>
                    Для расшифрования шифротекста все используемые шифрующие преобразования
                    могут быть инвертированы и применены в обратном порядке.
                </p>
                <p>
                    Перед первым раундом дешифрования выполняется операция AddRoundKey,
                    накладывающая на шифротекст четыре последних слова расширенного ключа.
                </p>
                <p>
                    Затем выполняется 10 раундов дешифрования, каждый из которых осуществляет
                    такие операции:
                </p>
                <ol>
                    <li>
                        Операция InvShiftRows, обратная операции ShiftRows. Байты в последних
                        трех строках матрицы <em>State </em>циклически сдвигаются влево на
                        различное число байт. Первая строка неподвижна, а нижние три строки
                        сдвигаются влево на 1, 2 и 3 байта соответственно.
                    </li>
                    <li>
                        Операция InvSubBytes, обратная операции SubBytes. Байты матрицы    <em>State </em>заменяются новыми значениями по таблице обратной замены,
                        являющейся инвертированным <em>S</em>-боксом. (см. табл.)

                        <p align="center">
                            <img
                                    width="626"
                                    height="437"
                                    src="../../images/lb3/23.png"
                            />
                        </p>
                    </li>
                    <li>
                        <p>Операция InvMixColumns – процедура, обратная процедуре MixColumns.</p>
                        <p>
                            Каждый столбец матрицы State рассматривается как четырехчленный многочлен
                            над полем GF (2<sup>3</sup>)
                            и умножается на фиксированный многочлен
                            с<sup>-1</sup>(x) = (0B) x<sup>3</sup>  +  (0D) x<sup>2</sup>  +  (09) x  +  (0E)
                        </p>
                        <p>
                            по модулю многочлена x<sup>4</sup>  +  1.
                        </p>
                        <p>
                            Такую операцию можно записать в матричном виде
                        </p>
                        <p align="center">
                            <img

                                    src="../../images/lb3/24.jpg"
                            />
                        </p>
                        <p align="center">

                            <img

                                    src="../../images/lb3/25.jpg"
                            />
                            – столбец матрицы <em>State</em>.
                        </p>
                    </li>
                    <li>
                        <p>
                            Операция AddRoundKey является обратной сама к себе, так как состоит
                            только в суммировании по mod 2 .
                        </p>
                        <p>
                            Последний раунд расшифрования не содержит операцию InvMixColumns.
                        </p>
                        <p>
                            В алгоритме расшифрования последовательность преобразований отличается от
                            порядка операций шифрования, а алгоритм расширения ключа остается
                            неизменным.
                        </p>
                        <p>
                            Однако два свойства алгоритма AES позволяют построить другую эквивалентную
                            процедуру расшифрования, где последовательность операций преобразования
                            остается той же самой (естественно с заменой операций на обратные).
                        </p>
                        <p>
                            Это
                        </p>
                        <ul>
                            <li>
                                коммутативность операций SubBytes и ShiftRows;
                            </li>
                            <li>
                                линейность операций перемешивания в столбце MixColumns и InvMixColumns по
                                отношению к данным столбца, что означает
                            </li>
                        </ul>

                        <p>
                            <em>InvMixColumns</em>(<em>State</em> ⊕ RoundKey)=InvMixColumns(<em>State</em>
                            ) ⊕ InvMixColumns(RoundKey).
                        </p>
                        <p>
                            Это дает возможность инвертировать порядок выполнения процедур <em>InvSubBytes</em>
                            и <em>InvShiftRows.</em>
                        </p>
                        <p>
                            Если же дополнительно в последовательности раундовых ключей изменить слова
                            с помощью процедуры <em>InvMixColumns</em> (не трогая первые и последние четыре
                            слова), то порядок выполнения процедур <em>AddRoundKey</em> и <em>InvMixColumns</em> тоже
                            можно изменить на обратный.
                        </p>
                    </li>
                </ol>
            </li>
            </ol>

            <br clear="all"/>
            <p>
                <strong style="font-size: 18px">
                    ЗАДАНИЕ:
                </strong>

                <ol>
                    <li>
                        Изучить теоретические сведения.
                    </li>
                    <li>
            <p>Создать программы, читающие данные из файла и шифрующие (дешифрующие) их
            в файл их с помощью с помощью стандарта AES на языке программирования С++.</p>
            </li>
            <li>
                По результатам каждой работы студентом должен быть представлен и
                защищен отчет. <br>
                <p>
                    <strong>Содержание отчета включает:</strong>
                <ol>
                    <li>
                        Титульный лист
                    </li>
                    <li>
                        Постановку задачи и описание использованных алгоритмов.
                    </li>
                    <li>
                        Блок – схему алгоритма.
                    </li>
                    <li>
                        Распечатку скриншотов результатов ввода данных и исполнения программы.
                    </li>
                    <li>
                        Распечатку программного кода.
                    </li>
                    <li>
                        Вывод.
                    </li>
                </ol>

        </td>
        <td id="col3"></td>
    </tr>
</table>
</body>
</HTML>
