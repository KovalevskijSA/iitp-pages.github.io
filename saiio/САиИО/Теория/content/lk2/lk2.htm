<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
	<title>Тема 2 Динамическое программирование</title>
	<meta http-equiv="Content-Language" content="ru" />
	<link rel="stylesheet" type="text/css" href="../../css/textStyle.css">
	<script type="text/javascript" src="http://latex.codecogs.com/latexit.js"></script>
</head>
<body>
	<div title="top" class="div-p-top">
		<h1 class="Top">
			<a href="../lk1/lk1.htm">[предыдущая тема]</a>
			<a href="../../theory.htm">[оглавление]</a>
			<a href="../lk6/lk6.htm">[следующая тема]</a>
		</h1>
		<hr>
		<p>&nbsp;</p>
		<h1>Тема 2 Динамическое программирование</h1>
		<p>&nbsp;</p>
		<hr>
		<p>&nbsp;</p>
	</div>
	<style>
        img {
            vertical-align: middle;

 }


    </style>

	<p>
		&emsp;<a href="#t1">2.1 Основные принципы динамического программирования</a><br>
		&emsp;<a href="#t2">2.2 Задача распределения ресурсов</a><br>
		&emsp;&emsp;<a href="#t2.2.1">2.2.1 Постановка задачи</a><br>
		&emsp;&emsp;<a href="#t2.2.2">2.2.2 Алгоритм решения</a><br>
		&emsp;&emsp;<a href="#t2.2.3">2.2.3 Пример</a><br>
		&emsp;<a href="#t3">2.3 Задача сетевого планирования</a><br>
		&emsp;&emsp;<a href="#t2.3.1">2.3.1 Постановка задачи</a><br>
		&emsp;&emsp;<a href="#t2.3.2">2.3.2 Метод динамического программирования</a><br>
		&emsp;&emsp;<a href="#t2.3.3">2.3.3 Алгоритм метода пометок</a><br>
		&emsp;&emsp;<a href="#t2.3.4">2.3.4 Пример</a><br>
	</p>
	<div align="justify" style="font-size: 14pt;">
	<br>
	<font size="4">&emsp;Динамическим программированием называется вычислительный метод решения специальных задач математического программирования
 и оптимального управления, математические модели которых имеют характер многоэтапных и динамических процессов.</font><br>
  <br>
  <br>
  <p class="title"><a name="t1"><b>2.1 Основные принципы динамического программирования</b></a></p>



<br>
&emsp;В динамических методах приближения к решению (оптимальному плану) 
  строятся по решениям последовательности аналогичных задач меньшей размерности 
  (состоящих из меньшего числа этапов). Процесс решения как бы развертывается 
  во времени. В статических методах количество этапов фиксировано и итерации представляют 
  переходы от одного элемента (плана) к другому в пространстве фиксированной размерности.
	
	
  <br>&emsp;Для того, чтобы применить методы динамического программирования, 
  необходимо, чтобы математическая модель решаемой задачи имела "динамический 
  характер". Не всегда в исходной постановке задачи удается разглядеть ее "динамический 
  характер". Поэтому очень важно научиться представлять модели в таком виде, в 
  котором выявляются их динамические свойства.<br>
  <br>&emsp;Однако не существует простых правил, механическое применение 
  которых в любой задаче позволяет выявить ее динамические свойства. Это в некоторой 
  степени является искусством. И здесь лучшим учителем является опыт и интуиция.
	<br>
  &emsp;Многие конкретные оптимизационные задачи удается сформулировать 
  несколькими внешне различными способами, причем в каждой из формулировок в центре 
  внимания находится та или иная структурная зависимость.<br><br>
<strong>&emsp;Метод динамического программирования основан на трех 
  главных этапах:</strong>
  <ol>
    <li> <i>Инвариантное погружение</i> исходной задачи в семейство аналогичных задач (исходная задача должна принадлежать этому семейству). Реализация 
      этого этапа может быть неоднозначной и в каждом конкретном случае зависит 
      от опыта, изобретательности и интуиции исследователя. От вида инвариантного 
      погружения зависят все последующие построения и эффективность полученного 
      метода в целом. На первом этапе, когда настроено инвариантное погружение, 
      вводится <i>функция Беллмана - оптимальное значение целевой функции произвольной 
      задачи</i> из рассматриваемого семейства.
			
    </li>
    <li> Второй этап решения задачи методом динамического программирования 
      состоит в получении <i>уравнения для функции Беллмана</i>. На этом этапе используется 
      <i>принцип оптимальности Беллмана</i>: оптимальная стратегия обладает тем 
      свойством, что, каков бы ни был путь достижения некоторого состояния, последующие 
      решения должны принадлежать оптимальной стратегии для оставшейся части процесса, 
      начинающегося с этого состояния.
       </li>
    <li> Поиск решения уравнения Беллмана и построение по нему 
      решения исходной задачи. </li>
  </ol>
	
	<br>
  &emsp;Изложим основные приемы метода динамического программирования на ряде конкретных задач линейного программирования.
<br>
<br>
<br>
<p class="title"><a name="t2"><b>2.2 Задача распределения ресурсов</b></a></p>
<p class="title"><a name="t2.2.1"><b>2.2.1. Постановка задачи</b></a></p>


<br>
&emsp;Имеется сырье в объеме <i> c</i>  и <i> n</i>  технологических процессов. Если количество <i>x</i>  сырья используется в <i>i</i>-м технологическом процессе,
 то получается прибыль
 <div* lang="latex">f_{i} (x). </div*>
 Как распределить сырье между процессами, чтобы получить максимальную прибыль?

Пусть
 <div* lang="latex">x_{i} </div*>
  -- количество сырья, выделяемое на <i>i</i>-й процесс. Тогда математическая модель сформулированной задачи имеет вид

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(1)">
<div lang="latex" align="center">
\sum _{i=1}^{n}f_{i} (x_{i} )\to \max  , \sum _{i=1}^{n}x_{i} =c , x_{i} \ge 0, i=\overline{1,n}.
</div>
 </td>
      <td width="2%">(1)</td>
    </tr>
  </table>
<br>
Специфика задачи нелинейного программирования <a href="#(1)">(1)</a> состоит в том, что его целевая функция и функция ограничений <i>сепарабельны</i>, т.е.
 представимы в виде суммы функций одной переменной.


Решим задачу <a href="#(1)">(1)</a> методом динамического программирования.


<br>
  <br>
  <br>
  <p class="title"><a name="t2.2.2"><b>2.2.2 Алгоритм решения</b></a></p>
	<br>
  &emsp;<strong>Осуществим первый этап</strong> - инвариантное погружение в семейство 
  задач. Для задачи <a href="#(1)">(1)</a> этот этап состоит в рассмотрении совокупности задач распределения 
  ресурсов в объеме<em> y</em> между <em>k</em> технологическими процессами:
	
  <br>

    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(2)">
<div lang="latex" align="center">
P(k,y):{\rm \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; \; }\sum _{i=1}^{k}f_{i} (x_{i} ) \to \max , \sum _{i=1}^{k}x_{i} =y , x_{i} \ge 0, i=\overline{1,k},
</div>
 </td>
      <td width="2%">(2)</td>
    </tr>
  </table>
<br>


где 
<div* lang="latex">0\le y\le c, \; 0\le k\le n,</div*>
 -- параметры семейства.
  <br>
&emsp;При <i> y = c</i> и <i>k = n</i>  получим исходную задачу.

<br>
&emsp;Оптимальное значение целевой функции задачи <a href="#(2)">(2)</a> назовем <i>функцией Беллмана</i>
<div* lang="latex">B_{k} (y):</div*>


<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(3)">
<div lang="latex" align="center">
B_{k} (y)=\max \sum _{i=1}^{k}f_{i} (x_{i} ) , \sum _{i=1}^{k}x_{i} =y , x_{i} \ge 0, i=\overline{1,k}.
</div>
 </td>
      <td width="2%">(3)</td>
    </tr>
  </table>
<br>

<br>
&emsp;<b>Перейдем ко второму этапу</b> -- составлению уравнения Беллмана на основе принципа оптимальности. 
Сущность этого принципа для задачи <a href="#(1)">(1)</a> выражается приводимыми ниже рассуждениями.

<br>
&emsp;Отметим, что при составлении уравнения Беллмана проверяется правильность инвариантного погружения. С другой стороны, способ погружения сказывается на виде уравнения.

<br>
&emsp;В задаче <a href="#(2)">(2)</a> с <i>k</i>  процессами и запасом сырья  <i>y</i>  выделим  <i>k</i>-му процессу сырье в 
количестве  <i>z</i> , 
<div* lang="latex">0\le z\le y.</div*>
 При этом размер прибыли от  <i>k</i>-го процесса будет равен 
 <div* lang="latex">f_{k} (z).</div*>

<br>
&emsp;На оставшиеся процессы с номерами 
<div* lang="latex">1, 2, \dots ,k-1</div*> 
остается сырья в количестве 
 <div* lang="latex">y-z.</div*>
 Из принципа оптимальности следует, что это сырье 
 <div* lang="latex">y-z </div*>
 между процессами 
  <div* lang="latex">1, 2, \dots ,k-1 </div*>
  нужно распределять оптимальным образом, ибо в противном случае при заданном количестве сырья <i>z</i>  для <i>k</i>-го процесса можно получить большую прибыль, если сырье в объеме 
  <div* lang="latex">y-z</div*>
   разделить между процессами 
   <div* lang="latex">1, 2, \dots ,k-1</div*>  
   оптимальным образом.

<br>
&emsp;Согласно определению <a href="#(3)">(3)</a>, размер максимальной прибыли от распределения 
<div* lang="latex">y-z</div*>
 единиц ресурса между процессами 
 <div* lang="latex">1, 2, \dots ,k-1</div*>  равен 
 <div* lang="latex">B_{k-1} (y-z).</div*>

<br>
&emsp;Таким образом, если запас сырья равен <i>y</i> , то при выделении <i>k</i>-му процессу <i>z</i> единиц ресурса от всех <i>k</i> процессов получаем прибыль

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(4)">
<div lang="latex" align="center">
f_{k} (z)+B_{k-1} (y-z).
</div>
 </td>
      <td width="2%">(4)</td>
    </tr>
  </table>
<br>

<br>
&emsp;Изменяя количество <i>z</i>  в пределах 
<div* lang="latex">0\le z\le y, </div*>
находим значение 
<div* lang="latex">x_{k}^{0} (y) </div*>
-- оптимальное количество сырья на 
<i>k</i>-й процесс, при котором общая прибыль <a href="#(4)">(4)</a> максимальна:

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(5)">
<div lang="latex" align="center">
f_{k} (x_{k}^{0} (y))+B_{k-1} (y-x_{k}^{0} (y))=\mathop{\max }\limits_{z} \, {\rm [}f_{k} (z)+B_{k-1} (y-z){\rm ]}, 0\le z\le y.
</div>
 </td>
      <td width="2%">(5)</td>
    </tr>
  </table>
<br>
С другой стороны, согласно <a href="#(3)">(3)</a>, максимальная прибыль от <i>k</i> процессов при количестве сырья <i>y</i> равна 
<div* lang="latex">B_{k} (y).</div*>
 Учитывая это, получаем
 

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(6)">
<div lang="latex" align="center">
B_{k} (y)=\mathop{\max }\limits_{0\le z\le y} {\rm [}f_{k} (z)+B_{k-1} (y-z){\rm ]}, k=\overline{1,n}, 0\le y\le c.
</div>
 </td>
      <td width="2%">(6)</td>
    </tr>
  </table>
<br>
<br>
&emsp;Параллельно с функцией 
<div* lang="latex">B_{k} (y) </div*>
можно строить функцию 
<div* lang="latex">x_{k}^{0} (y),\;\; 0\le y\le c, </div*>
где 
<div* lang="latex">x_{k}^{0} (y)</div*>
 -- значение параметра 
 <div* lang="latex">z\in [0,y], </div*>
 на котором достигается максимум в правой части выражения <a href="#(6)">(6)</a>.

<br>
&emsp; Уравнение <a href="#(6)">(6)</a> называется <i>уравнением Беллмана</i>.

<br>
&emsp;Поскольку уравнение <a href="#(6)">(6)</a> рекуррентно относительно аргумента <i>k</i> функции
 <div* lang="latex">B_{k} (y),</div*>
  то для его решения необходимо задать начальное условие. Это условие можно получить из <a href="#(3)">(3)</a>, если положить <i>k =1</i>:
  <br>
	<br>
<div lang="latex" align="center">B_{1} (y)=\max f_{1} (x_{1} ), x_{1} =y, x_{1} \ge 0.</div>
<br>



<br>
&emsp;Таким образом, начальное условие для уравнения Беллмана <a href="#(6)">(6)</a> имеет вид


<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(7)">
<div lang="latex" align="center">
B_{1} (y)=f_{1} (y).
</div>
 </td>
      <td width="2%">(7)</td>
    </tr>
  </table>
<br>

<br>
&emsp;<b>Рассмотрим третий этап</b> -- поиск решения уравнения Беллмана <a href="#(6)">(6)</a>, <a href="#(7)">(7)</a> и построение по нему решения исходной задачи.

<br>
&emsp;Начальное условие у нас задано -- это условие <a href="#(7)">(7)</a>. В уравнении <a href="#(6)">(6)</a> положим <i>k= 2</i>:

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(8)">
<div lang="latex" align="center">
B_{2} (y)=\mathop{\max }\limits_{0\le z\le y} {\rm [}f_{2} (z)+B_{1} (y-z){\rm ]}=\mathop{\max }\limits_{0\le z\le y} {\rm [}f_{2} (z)+f_{1} (y-z){\rm ]}.
</div>
 </td>
      <td width="2%">(8)</td>
    </tr>
  </table>
<br>
В этом выражении под знаком максимума стоят известные функции. Поэтому формула <a href="#(8)">(8)</a> позволяет вычислить 
<div* lang="latex">B_{2} (y)</div*>
 максимизацией  известной  функции
одной переменной. 

<br>
&emsp;Положим далее в <a href="#(6)">(6)</a> <i>k=3</i>:

<br>
	<br>
<div lang="latex" align="center">B_{3} (y)=\mathop{\max }\limits_{0\le z\le y} {\rm [}f_{3} (z)+B_{2} (y-z){\rm ]}.</div>
<br>

Функция
 <div* lang="latex">f_{3} (y)</div*>
  задана, функция 
  <div* lang="latex">B_{2} (y)</div*>
   определена выше, следовательно, под знаком максимума стоит известная функция и мы можем теперь определить функцию 
   <div* lang="latex">B_{3} (y) </div*>
   максимизацией известной функции одной переменной \textit{z}. И так далее. В результате будут построены функции 
   <div* lang="latex">B_{1} (y),\;  \dots , \; B_{n} (y), \;\ 0\le y\le c. </div*>
   Согласно <a href="#(3)">(3)</a>, число 
   <div* lang="latex">B_{n} (c)</div*>
    -- максимальная прибыль для исходной задачи <a href="#(1)">(1)</a>.

<br>
&emsp;Чтобы найти оптимальное распределение сырья по технологическим процессам, 
обратимся к выражению <a href="#(5)">(5)</a> и совершим <i>обратный ход решения уравнения Беллмана</i>.

<br>
&emsp;Положим в <a href="#(5)">(5)</a> <i>k=n</i> , <i>y=c</i>  и, согласно <a href="#(5)">(5)</a>, найдем число
 <div* lang="latex">x_{n}^{0} (c),</div*>
  которое, по определению, равно оптимальному количеству сырья, выделяемому на процесс <i>n</i>, 
  если объем сырья на все <i>n</i> процессов равен <i>c</i>. Таким образом, компонента 
  <div* lang="latex">x_{n}^{0}  </div*>
  оптимального плана 
  <div* lang="latex">x^{0} =(x_{1}^{0} ,\, x_{2}^{0} ,\, ...,\, x_{n}^{0} ) </div*>
  исходной задачи <a href="#(1)">(1)</a> определена:
   <div* lang="latex">x_{n}^{0} =x_{n}^{0} (c).</div*>

<br>
&emsp;Если <i>n</i>-му процессу выделили 
<div* lang="latex">x_{n}^{0} </div*>
 единиц сырья, то на остальные <i>n-1</i> процессов осталось 
 <div* lang="latex">c-x_{n}^{0} </div*>
  единиц.

<br>
&emsp;Положим в <a href="#(5)">(5)</a>
 <div* lang="latex">k=n-1,\; y=c-x_{n}^{0}</div*>  
 и найдем 
 <div* lang="latex">x_{n-1}^{0} (c-x_{n}^{0} ).</div*>
  По определению 
  <div* lang="latex">x_{n-1}^{0} (c-x_{n}^{0} )</div*>
   равно оптимальному количеству сырья, которое дается <i>n-1</i>-му процессу при условии, что 
   <div* lang="latex">c-x_{n}^{0}  </div*>
   единиц сырья надо разделить оптимальным образом между первыми <i>n-1</i> процессами. Таким образом, получаем 
   <div* lang="latex">x_{n-1}^{0} =x_{n-1}^{0} (c-x_{n}^{0} ).</div*>

<br>
&emsp;Продолжив процесс решения, найдем компоненты 
<div* lang="latex">x_{n-2}^{0} ,\, \, ...,\, \, x_{1}^{0}</div*>  
решения исходной задачи <a href="#(1)">(1)</a>. Проанализируем результат.

<br>
<br>

<br>
&emsp;<b>Достоинства метода</b>:
<br>
<br>
<br>
&emsp;1. Исходная задача <a href="#(1)">(1)</a> максимизации по <i>n</i> переменным свелась к <i>(n-1)</i> задачам 
<a href="#(6)">(6)</a> максимизации по одной переменной, причем результат -- глобально оптимальный план.
<br>
<br>
&emsp;2. В процессе решения не использовались аналитические свойства элементов задачи, исходные функции могли быть заданы таблично, графически, алгоритмически и т.д.
<br>
<br>
&emsp;3. По результатам вычислений 
<div* lang="latex">B_{k} (y)</div*> 
легко построить решение задачи <a href="#(1)">(1)</a> при варьированных значениях параметров <i> c</i> и <i>n</i>, 
что позволяет провести анализ чувствительности решений задачи <a href="#(1)">(1)</a> к изменениям указанных параметров.

<br>
<br>


<br>
&emsp;<b>Недостатки метода</b>

<br><br>


&emsp;Основным недостатком метода является <i>«проклятие размерности»</i>. Суть этого недостатка состоит в том, что 
при решении уравнения Беллмана <a href="#(6)">(6)</a> приходится запоминать функции 
<div* lang="latex"> B_{k} (y)</div*>. 
В рассмотренной выше задаче с распределением сырья одного вида ими оказались 
функции одного аргумента. В общем случае количество аргументов равно количеству видов сырья.
 Табулирование функций многих переменных (<i>n>2</i>) требует очень много места в оперативной памяти, что затрудняет реализацию метода.

<br>
&emsp;Существуют способы борьбы с «проклятием размерности», но эти способы годятся не для всех задач.

<br>
<br>


<a name="t2.2.3"><b>&emsp;Пример</b></a>. Рассмотрим пример с данными из <a href="#table2_1">табл. 2.1.</a><br>
  <p id="table2_1" align="right">Таблица 2.1</p>
  <center><i>c</i> = 5, <i>n</i> = 3</center>
  
  <table width="100%" border="0">
    <tr>
      <td width="98%">
        <div align="center"><font size="4"><img src="../../images/lk2/img2_1/34.gif" width="283" height="143"  border="0" align="absmiddle" alt=""></font></div>
      </td>
      <td width="2%">&nbsp;</td>
    </tr>
  </table>

<br>
&emsp; Определим функции Беллмана по правилу:    

<div* lang="latex">B_{1} (y)=f_{1} (y)</div*>,


<br>
	<br>
<div lang="latex" align="center">B_{2} (y)=\mathop{\max }\limits_{0\le z\le y} {\rm [}f_{2} (z)+B_{1} (y-z){\rm ]},
 B_{3} (y)=\mathop{\max }\limits_{0\le z\le y} {\rm [}f_{3} (z)+B_{2} (y-z){\rm ],}\, \, \, 0\le y\le c=5{\rm .}</div>
<br>

Например,

<br>
	<br>
<div lang="latex" align="center">B_{2} (4)=\mathop{\max }\limits_{0\le z\le 4} (f_{2} (z)+B_{1} (4-z))=</div>
	<br>
<div lang="latex" align="center">=\{ f_{2} (0)+B_{1} (4),f_{2} (1)+B_{1} (3),f_{2} (2)+B_{1} (2),</div>
<br>
	
<div lang="latex" align="center">
f_{2} (3)+B_{1} (1),\, f_{2} (4)+B_{1} (0)\} =4.</div>

<br>
<br>

 











<br>
&emsp;Значения функций Беллмана представим в <a href="#table2_2">табл. 2.2</a>, где в каждой клетке наряду со значением функции Беллмана 

<div* lang="latex">B_{k} (y)</div*>

 в скобках укажем значение 

<div* lang="latex">x_{k}^{0} (y)</div*>,
 
на котором достигает максимума правая часть уравнения <a href="#(6)">(6)</a>.

<p id="table2_2" align="right">Таблица 2.2</p>
  <table width="100%" border="0">
    <tr>
      <td width="98%">
        <div align="center"><font size="4"><img src="../../images/lk2/img2_1/36.gif" width="283" height="136"  border="0" align="absmiddle" alt=""></font></div>
      </td>
      <td width="2%">&nbsp;</td>
    </tr>
  </table><br>


<br>
&emsp; Из <a href="#table2_2">табл. 2.2</a> видно, что максимальная прибыль в рассматриваемой задаче равна 
<div* lang="latex">B_{3} (5)=7</div*>. 
Найдем оптимальное распределение ресурсов. Поскольку 
<div* lang="latex">x_{3}^{0} (5)=0</div*>, 
то третьему технологическому процессу назначаются ресурсы в объеме 
<div* lang="latex">x_{3}^{0} =0</div*>.
 На остальные процессы 1 и 2 остается ресурсов 
5-0=5.
 Прибыль от реализации процессов 1, 2 при объеме ресурсов 5 равна 
<div* lang="latex">B_{2} (5)=7</div*>
 и 
<div* lang="latex">x_{2}^{0}(5)=5</div*>.
Значит, второму процессу назначается ресурс в объеме 5: 
<div* lang="latex">x_{2}^{0} =5</div*>. На первый процесс остается ресурса в объеме 5 -- 5 = 0.
 Следовательно, 
<div* lang="latex">x_{1}^{0} =0</div*>.


<br>
&emsp; Получили оптимальный план

 <br>
	<br>
<div lang="latex" align="center">(x_{1}^{0} =0,\; x_{2}^{0} =5,\; x_{3}^{0} =0).</div>
<br>
<br>

<br>
&emsp;Изменим теперь в задаче одно условие: положим теперь <i>c</i>=4. Согласно таблице, имеем: 
<div* lang="latex">B_{3} (4)=5</div*>
 -- это максимальная прибыль, 
<div* lang="latex">x_{3}^{0} (4)=1</div*>. 
Следовательно, на первый и второй процессы остается ресурса в объеме 
4-1=3. Далее по <a href="#table2_2">табл. 2.2</a> находим 
<div* lang="latex">B_{2} (3)=3</div*> и 
<div* lang="latex">x_{2}^{0} (3)=0</div*>. На первый процесс остается ресурса в объеме 3 -- 0 = 3.
 
<br>
&emsp;Оптимальный план распределения ресурсов 

<br>
	<br>
<div lang="latex" align="center">(x_{1}^{0} =3, \; x_{2}^{0} =0,\; x_{3}^{0} =1).</div>
<br>



<br>
  <br>
	<p class="title"><a name="t3"><b>2.3 Задача сетевого планирования</b></a></p>
	<p class="title"><a name="t2.3.1"><b>2.3.1. Постановка задачи</b></a></p>

<br>
В <i>сетевом планировании</i> исследуются проблемы реализации сложных проектов (комплексов работ),
 состоящих из большого количества отдельных работ, которые должны выполняться в определенной технологической

<br>
&emsp;Составим сетевую модель задачи. Факт (явление) начала (или окончания)
 какого-либо множества работ из заданной совокупности работ проекта назовем 
<i>событием</i> и поставим ему в соответствие узел 
<div* lang="latex">i \in I</div*>.
 Работу, которая может начаться после события 
<div* lang="latex">i \in I</div*>
 и которая предшествует событию <i>j</i>, обозначим дугой
<div* lang="latex">(i,j)\in U</div*>.
 Ни одна работа 
<div* lang="latex">(i,j)\in U</div*> 
не может начаться, если не завершены все работы 

<br>
	<br>
<div lang="latex" align="center">(k,i) \in  U,\;  k \in  I_{i}^{-}  = \{k\in I: \ \exists\; (k,i) \in U\}, </div>
<br>

т.е. ни одна работа

<div* lang="latex">(i,j)\in U</div*> 
 не может начаться до наступления события <i>i</i>;
 момент наступления события <i>i</i> определяется моментом завершения <b>всех</b>  работ 
<div* lang="latex">(k,i), \; k \in I_{i}^{-} </div*>.


<br>
&emsp;Определения основных понятий на сети  
<div* lang="latex">S=\{I,U\}</div*> 
приведены в разделе <a href="../lk6/lk6.htm">[Задача о потоке минимальной стоимости]</a>.

<br>
&emsp;На сети 
<div* lang="latex">S=\{I,U\}</div*>
 выделим два узла: <i>s</i> s}  --- начальное событие (начало выполнения проекта) и  <i>t</i> --- конечное событие (завершение проекта). 
По построению верны соотношения 
<div* lang="latex">I_{s}^{-} =\emptyset</div*>, 
<div* lang="latex">I_{t}^{+} =\emptyset</div*>, где

<br>
	<br>
<div lang="latex" align="center">I_{i}^{+}  = \{j \in \textit{I}: \exists\;  ({i}, {j}) \in \textit{U}\}.</div>
<br>


<br>
&emsp;Каждой дуге
 <div* lang="latex">(i,j)\in U</div*> 

 припишем одну характеристику 
<div* lang="latex">c_{ij} >0</div*>
 ---  время выполнения работы 
<div* lang="latex">(i,j)</div*>. 
Обозначим через 
<div* lang="latex">x_{i} , {i} \in  I,</div*>
 момент наступления события <i>i</i>; 
<div* lang="latex">x_{s}  = 0.</div*>

 <br>
&emsp;Из технологических требований, имеющихся в проекте и отраженных в структуре сети 
<i>S</i>,
 следуют неравенства

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(9)">
<div lang="latex" align="center">
x_{i} +c_{ij} \le x_{j} ,\, \, i\in I_{j}^{-} ,\, \, j\in I,
</div>
 </td>
      <td width="2%">(9)</td>
    </tr>
  </table>
<br>
которые означают, что событие <i>j</i> наступает не раньше, чем будут завершены все работы 
<div* lang="latex">({i}, {j}), \; {i} \in I_{j}^{-} </div*>, 
которые предшествуют этому событию <i>j</i>.

<br>
&emsp;Из <a href="#(9)">(9)</a> следует, что в сети 
<i>S</i> 
нет контуров. Действительно, предположим, что в  <i>S</i>
существует контур и обозначим через 
<div* lang="latex">U_{k}\subset U</div*> 
дуги этого контура. Просуммируем неравенства <a href="#(9)">(9)</a> по дугам 
<div* lang="latex">({i}, {j}) \in U_{k} </div*> и получим


<br>
	<br>
<div lang="latex" align="center">\sum _{(i,j)\in U_{k} }c_{ij}   \leq 0.</div>
<br>


Однако это противоречит предположению 


<div* lang="latex">c_{ij}>0, \ (i,j)\in U.</div*>


<br>
&emsp;Далее будем предполагать, что

<br>
	<br>
<div lang="latex" align="center">I_{i}^{+} \neq \emptyset, \; {i} \in {I} \setminus  t; \;\; I_{i}^{-} \neq \emptyset, i \in I\setminus s.</div>
<br>

 ибо этого всегда можно добиться, модифицируя сеть 
<i>S</i>
и не нарушая технологической последовательности выполнения работ.

<br>
&emsp;Минимальное время выполнения проекта определяется наименьшим числом 
<div* lang="latex">x_{t}^{0} </div*>,
 которое в совокупности с числами

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(10)">
<div lang="latex" align="center">
x_{i}^{0} \ge 0,\, \, i\in I\backslash t;\, \, \, x_{s}^{0} =0
</div>
 </td>
      <td width="2%">(10)</td>
    </tr>
  </table>
<br>

 удовлетворяет неравенствам <a href="#(9)">(9)</a>.

<br>
&emsp;Поскольку для окончания проекта необходимо, чтобы все работы были завершены, то длина каждого пути из 
<i>s</i>  в <i>t</i>, равная сумме 
<div* lang="latex">\sum c_{ij}</div*>, 
вычисленной вдоль дуг пути, не меньше чем 
<div* lang="latex">x_{t}^{0} </div*>. 
Чтобы убедиться в этом, достаточно сложить неравенства <a href="#(9)">(9)</a> вдоль этого пути. 
<br>
&emsp;С другой стороны, очевидно, что найдется такая последовательность работ, составляющая путь из <i>s</i>  в <i>t</i>, 
общая продолжительность которых равна 
<div* lang="latex">x_{t}^{0} </div*>.

<br>
&emsp;Таким образом, задача вычисления 
<div* lang="latex">x_{t}^{0} </div*> 
сводится к поиску пути из <i>s</i>  в <i>t</i> с максимальной длиной 
<div* lang="latex">\sum c_{ij}  </div*>. 

Такой путь принято называть <i>критическим</i>.

<br>
&emsp;Заметим, что сформулированная задача:

 найти 

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(11)">
<div  align="center">
<div* lang="latex">x_{t} -x_{s} \to \min</div*> </div>

 <div  align="center"> при условиях <a href="#(9)">(9)</a>, <a href="#(10)">(10)</a></div>
</td>
      <td width="2%">(11)</td>
    </tr>
  </table>
<br>  

    
является двойственной к задаче о потоке минимальной стоимости (см. раздел <a href="../lk6/lk6.htm">[Задача о потоке минимальной стоимости]</a>.) на сети 
<i>S</i>  с дуговыми стоимостями 
<div* lang="latex"> -c_{ij}, (i,j) \in U,</div*>
  и интенсивностями узлов 
	
	<br>
	<br>
<div lang="latex" align="center">a_{s} =1, \ a_{t} =-1, \; a_{i} = 0, {i} \in I} \setminus  \{{s}, {t}\}.</div>
<br>
	
	При этом числа 
	<div* lang="latex">x_{i}^{0} , {i} \in {I}</div*>
	
	-- оптимальные потенциалы в задаче о потоке минимальной стоимости. Следовательно, задачу <a href="#(11)">(11)</a> можно решать
	<i>методом потенциалов</i>, который был рассмотрен в  разделе <a href="../lk6/lk6.htm">[Задача о потоке минимальной стоимости]</a>.

<br>
&emsp;Используя специфику задачи <a href="#(11)">(11)</a>, решим её методом динамического программирования.


<br>
  <br>
  <p class="title"><a name="t2.3.2"><b>2.3.2 Метод динамического программирования</b></a></p>
 


<br>

 <br>
&emsp;Итак, мы решаем задачу о построении критического (максимального) пути из<i>s</i>  в <i>t</i>.

<br>
&emsp;Согласно общей схеме динамического программирования, осуществим <b>первый этап </b>-- инвариантное погружение в семейство задач.

<br>
&emsp;Общая задача семейства состоит в построении максимального пути из <i>c</i> в любой узел 
<div* lang="latex">j \in I</div*>. 

Длина 
<div* lang="latex">B_j</div*> этого пути называется <i>функцией Беллмана</i>.

<br>
&emsp;Осуществим <b> второй этап</b>  -- составим уравнение Беллмана, которому удовлетворяет функция Беллмана 
<div* lang="latex">B_j</div*>. 
Для этого поступим следующим образом. Будем исследовать пути из <i>s</i>  в <i>j</i>. 

<br>
&emsp;Вначале предположим, что последней дугой пути из  <i>s</i>  в <i>j</i>
 является дуга 
<div* lang="latex">({i}, {j}) \in U</div*>, 
где 
<div* lang="latex">i\in I^-_j</div*>

 и что в узел <i>i</i>  из <i>s</i> мы попали вдоль пути максимальной длины, т. е. вдоль пути длины 

<div* lang="latex">B_i.</div*>
 Тогда длина рассматриваемого пути из  <i>s</i>  в <i>j</i> через <i>i</i>  равна

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(12)">
<div lang="latex" align="center">
B_i + c_{ij }.   
</div>
 </td>
      <td width="2%">(12)</td>
    </tr>
  </table>
<br>  

<br>
&emsp;Переберем все узлы 

<div* lang="latex">i\in I^-_j</div*>
 и найдем максимальное среди чисел <a href="#(12)">(12)</a>:


<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(13)">
<div lang="latex" align="center">
\max\limits_{i\in I_{j}^{-} }  (B_{i} +c_{ij} ).
</div>
 </td>
      <td width="2%">(13)</td>
    </tr>
  </table>
<br>

<br>
&emsp;Рассуждая от противного, легко показать, что число <a href="#(13)">(13)</a> равно длине максимального пути из <i>s</i>  в <i>j</i>.
 По определению длина максимального пути из <i>s</i>  в <i>j</i> равна 
<div* lang="latex">B_j</div*>,
 следовательно,

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(14)">
<div lang="latex" align="center">
B_{j}  = \max \limits_{i\in I_{j}^{-} } (B_{i} +c_{ij} ).
</div>
 </td>
      <td width="2%">(14)</td>
    </tr>
  </table>
<br>
Уравнение <a href="#(14)">(14)</a> -- это <b> уравнение Беллмана</b>.

<br>
&emsp;Значение функции Беллмана для узла s известно:

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(15)">
<div lang="latex" align="center">
B_{s}  = 0.
</div>
 </td>
      <td width="2%">(15)</td>
    </tr>
  </table>
<br>
Равенство <a href="#(15)">(15)</a> -- краевое (начальное) условие для уравнения <a href="#(14)">(14)</a>.

 <br>
&emsp;В отличие от рассмотренного ранее примера уравнение Беллмана <a href="#(14)">(14)</a> не является явно рекуррентным.

<br>
&emsp;Для решения уравнения <a href="#(14)">(14)</a> с начальным условием <a href="#(15)">(15)</a> разработаем специальный метод, называемый методом пометок.



<br>

<br>
<br>
  
 
  <p class="title"><a name="t2.3.3"><b>2.3.3 Алгоритм метода пометок</b></a></p>
<br>
<br>

&emsp;Обозначим через 

<div* lang="latex">I_*</div*> 
 множество узлов
<div* lang="latex">i \in I,</div*>  
 для которых известна функция Беллмана
<div* lang="latex">B_i</div*>.
 Множество 
<div* lang="latex">I_*</div*> 
не пусто, так как,

 согласно <a href="#(7)">(7)</a>, 
<div* lang="latex">s\in I_*.</div*>

 <br>
&emsp;Если 
<div* lang="latex">t \in I_*</div*>, то задача решена,
<div* lang="latex">B_t</div*>  
 -- длина максимального пути

 из <i>s</i>  в <i>t</i>. Для восстановления этого пути надо осуществить <i>«обратный ход» </i> решения уравнения Беллмана.
 Эту процедуру рассмотрим ниже. Для того чтобы легче осуществить «обратный ход», будем для узлов 
<div* lang="latex">i \in I_*</div*>
 кроме функции Беллмана 
<div* lang="latex">B_i</div*> 
 задавать еще функцию 
<div* lang="latex">f(i), i \in I_*.</div*>

 <br>
&emsp;На первом шаге имеем
<br>
<br>
<div lang="latex" align="center">I_*=\{s\}, \; \; B_s=0, \; f(s)=0.</div>
<br>




 <br>
&emsp;Пусть 
<div* lang="latex">t \not \in I_*. </div*> 
В сети <i>S</i> 
 построим множество узлов 
<br>
	<br>
<div lang="latex" align="center">w(I_*)=\{j \in I:\exists \ (i,j)\in U, \ i \in I_*, \ j \not \in I_*\},</div>
<br>

 соседних с множеством 
<div* lang="latex">I_*</div*>.
 В силу того, что в сети 
<i>S</i>
нет контуров, среди узлов 
<div* lang="latex">j \in w(I_*)</div*>

 обязательно найдется узел 
<div* lang="latex">j_*</div*>,

 для которого

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(16)">
<div lang="latex" align="center">
I^-_{j_*}\subset I_*.
</div>
 </td>
      <td width="2%">(16)</td>
    </tr>
  </table>
<br>






      
Поскольку для узлов 
<div* lang="latex">i \in I_*</div*>
 значения 
<div* lang="latex">B_i</div*> 
 функции Беллмана уже известны, то из уравнения <a href="#(14)">(14)</a> можно найти

<br>
<br>
    <table width="100%" border="0">
        <tr>
            <td width="98%"><img id="(17)">
                <div lang="latex" align="center">B_{j_*}=\max\limits_{i \in I^-_{j_*}}(c_{ij_*}+B_i)=c_{i_*j_*}+B_i_*.</div>
            </td>
            <td width="2%">(17)</td>
        </tr>
    </table>
<br>


 <br>
&emsp;Полагаем

<div* lang="latex">I_*=I_*\cup j_*, \; f(j_*)=i_*</div*> 
 и переходим к следующей итерации.


<br>
<br>
&emsp;<b> Замечание.</b>  Узлов типа 
<div* lang="latex">j_*</div*>, 
для которых верно <a href="#(16)">(16)</a>, может оказаться несколько. 
Для всех них по правилам <a href="#(17)">(17)</a> находим функцию Беллмана и функцию 
<div* lang="latex">f(j_*)</div*> 
и все эти узлы добавляем к множеству
 <div* lang="latex">I_*.</div*>
<br>
<br>
&emsp;Очевидно, что через конечное число (меньшее либо равное |<i>I</i>|) шагов мы придем к ситуации, 
когда 
<div* lang="latex">t \in I_*.</div*> 
 Это означает, что задача решена: 
<div* lang="latex">B_t</div*> 
 -- длина максимального пути из <i>s</i> в <i>t</i>.


<br>
&emsp;Осуществим «обратный ход» для нахождения максимального пути: 
<div* lang="latex">\{t,\ i_1,\ i_2,...,i_k,\ s \}</div*>
 по правилу:

<br>
    <br>
  <table width="100%" border="0">
    <tr>
      <td width="98%"><img id="(18)">
<div lang="latex" align="center">
i_1=f(t), \; i_2=f(i_1),\ ...,\  i_k=f(i_{k-1}), \; s=f(i_k).
</div>
 </td>
      <td width="2%">(18)</td>
    </tr>
  </table>
<br>





<br>
<a name="t2.3.4"><b>&emsp;Пример.</b> </a>
 
<br>
<br>
&emsp;
Рассмотрим сеть, изображенную <a href="#pic2_1">рис. 2.1</a>,, где <i>s</i>= 1, <i>t</i> = 4.


<table width="100%" border="0">
    <tr>
      <td width="98%">
        <div align="center"><font size="4"><img id="pic2_1" src="../../images/lk2/img2_2/54.gif" width="388" height="250"  border="0" align="abSmiddle" alt=""></font></div>
        <br><center><span>Рис. 2.1</span></center>
      </td>
      <td width="2%">&nbsp;</td>
    </tr>
  </table> 

Числа, указанные на дугах, равны длине соответствующей дуги.
 На этом же рисунке приведены значения функции Беллмана 
<div* lang="latex">B_{j} , \; \; j=\overline{1,6},</div*> 
определенные по методу пометок. Вторые метки 
<div* lang="latex">f(j),\; \; j=\overline{1,6}</div*>,
 позволяют восстановить критический путь из <i>s</i>  в <i>t</i> по правилу <a href="#(18)">(18)</a>:
<br>
<br>
<div lang="latex" align="center">i_{1} :=f(t)=3;{ \; \; \; }i_{2} :=f(3)=2;{ \; \; \; }i_{3} :=f(2)=6;{ \; \; \; }i_{4} :=f(1).</div>
<br>




<br>
&emsp; Следовательно, искомый путь имеет вид

<br>
<br>
<div lang="latex" align="center">s=1\to 6\to 2\to 3\to 4=t.</div>
<br>




<br>
&emsp;<b>Замечание.</b>  Работы, входящие в критический путь, должны начинаться в строго фиксированные моменты времени: например,
 работа 
<div* lang="latex">({i}, {j}) </div*>,
 вошедшая в критический путь, 
 не может (чисто физически) начаться раньше момента времени 
<div* lang="latex">x_{i}^{0} </div*>; 
если же она начнется позже момента 
<div* lang="latex">x_{i}^{0} </div*>, то это приведет к увеличению времени выполнения всего проекта.

<br>
&emsp;Для работ, не принадлежащих критическому пути, есть возможность несколько варьировать момент 
их начала без увеличения общей продолжительности выполнения всего проекта. Пусть дуга 
<div* lang="latex">(i,j)</div*>
 не принадлежит критическому пути, 
 тогда работа 
<div* lang="latex">(i,j) </div*>
 чисто физически не может начаться раньше момента 
<div* lang="latex">x_{i}^{0} </div*>. 
Но мы можем начать работу эту 
<div* lang="latex">(i,j)</div*> в любой момент вида



<div* lang="latex">x_{i}^{0} +\Delta t_{ij} ,</div*>
 где 
<div* lang="latex">\Delta t_{ij} \in {\rm [\; }0,\, x_{j}^{0} {\rm \; }-c_{ij} {\rm \; }-{\rm \; }x_{i}^{0} {\rm ]}</div*>,  



 без ущерба для общего времени выполнения проекта.

<br>
&emsp;Эту возможность «сдвига» работ некритического пути используют при сетевом планировании распределения 
ресурсов (например трудовых ресурсов), при решении следующей задачи: определить такие 
<div* lang="latex">\Delta t_{ij} , \ ({i}, {j}) \in {U}, </div*>
чтобы в каждый момент времени для выполнения текущих работ требовалось 
минимальное количество рабочих. Моменты времени 
<div* lang="latex">x_{i}^{0} , \ i \in I,</div*>  считаются уже найденными и фиксированными.

 </div>
	<div title="Bottom">
		<p>&nbsp;</p>
		<hr size="2" width="100%" align="center">
		<h1 class="Bottom">
			<a href="../lk1/lk1.htm">[предыдущая тема]</a>
			<a href="../../theory.htm">[оглавление]</a>
			<a href="../lk6/lk6.htm">[следующая тема]</a>
		</h1>
	</div>
</body>
</html>
